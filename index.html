<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Dongdong blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Dongdong blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dongdong blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dongdong blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Dongdong blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Dongdong blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Xmpp导入Xcode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/10/Xmpp导入Xcode/" class="article-date">
  <time datetime="2015-09-10T01:28:40.000Z" itemprop="datePublished">2015-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/10/Xmpp导入Xcode/">Xmpp导入Xcode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>XMPP是一种基于标准通用标记语言的子集XML协议，具有超强的可拓展性。经过拓展的XMPP可以通过发送拓展的信息来处理用户需求。XMPP包含了正对服务端的软件协议，使之能够与另一个进行通话。XMPP以Jabber协议为基础，而Jabber是即时通讯中常用的开放式协议。目前由IETF国际标准组织完成标准化工作。</p>
<p>标准化的核心分为两个部分</p>
<p>核心的XML流传输协议<br>基于XMLFreeEIM流传输的即时通讯扩展应用（这部分支持语音和视频）</p>
<p>优点：<br>开放，它是开放源码的，自由开放公开。</p>
<p>标准化，IETF 互联网工程工作小组标准化</p>
<p>成熟，第一个jabber技术是在1998年开发的，现在已经相当稳定</p>
<h2 id="xmpp_导入项目过程，需要添加的东西比较多，需要一步一步来">xmpp 导入项目过程，需要添加的东西比较多，需要一步一步来</h2><ol>
<li>从github下载最新的xmpp framework </li>
<li>添加一下文件夹到工程中<ul>
<li>Authentication</li>
<li>Categories</li>
<li>Core</li>
<li>Utilities</li>
<li>添加libresolv.dylib库到项目，确保编译通过</li>
</ul>
</li>
<li>将Vendor/CocoaLumberjack copy到工程中，确保编译通过</li>
<li>将Vendor/CocoaAsyncSocket copy到工程中，这个包需要添加苹果的CFNetwork framework和Security framework 添加完后确保编译通过</li>
<li>将Vendor/KissXML copy到工程中，KissXML使用libxml2，你需要添加苹果的libxml2库 到工程文件中。在Targets-&gt;BuildSettings-&gt;Search Paths-&gt; + -&gt;/usr/include/libxml2。 然后将libxml2.dylib库导入工程，确保编译通过。</li>
<li>添加最后一个依赖包是LIBLdn，添加下面的三个文件到Xcode工程文件<ul>
<li>Vendor/libidn/idn-int.h</li>
<li>Vendor/libidn/stringprep.h</li>
<li>Vendor/libidn/libidn.a</li>
</ul>
</li>
<li>现在你已经可以开始使用XMPPFramwork 在你的项目中</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/10/Xmpp导入Xcode/" data-id="ciedk5cs200063pi0oz2pgx0j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Xcode6-4添加pch文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/10/Xcode6-4添加pch文件/" class="article-date">
  <time datetime="2015-09-10T01:10:21.000Z" itemprop="datePublished">2015-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/10/Xcode6-4添加pch文件/">Xcode6.4添加pch文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Xcede6的Pch文件系统不在自动生成，需要手动添加。</p>
<p>添加步骤如下</p>
<ol>
<li>other 新建pch文件</li>
<li>在Build setting 中的Precomplie Prefix Heard 设置为yes</li>
<li>在Prefix Heard 中添加pch文件的相对路径 $(SRCROOT)/项目名/PrefixHeader.pch</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/10/Xcode6-4添加pch文件/" data-id="ciedk5crg00003pi0he210ygr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-设置appicon和启动图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/06/设置appicon和启动图/" class="article-date">
  <time datetime="2015-09-06T13:27:52.000Z" itemprop="datePublished">2015-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/06/设置appicon和启动图/">设置appicon和启动图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设置appicon">设置appicon</h2><p>General – App Icon Source  设置AppIcon </p>
<p>图片大小</p>
<p>iphone 6P（@3x）    180x180</p>
<p>iphone 6（@2x）</p>
<p>iphone5/5s （@2x）    120x120</p>
<p>iphone4/4s (@2x)</p>
<h2 id="设置launchimage">设置launchimage</h2><p>第一种方法</p>
<p>General – launch image source – use asset catalog  设置launchimage(删掉launchScreen.xib)</p>
<p>iphone 6P（@3x）  1242 x 2208 (@3x) for portrait –Retina HD 5.5</p>
<p>iphone 6（@2x）   750 x 1334 (@2x) for portrait – Retina HD 4.7</p>
<p>iphone5/5s （@2x）  640 x 1136 (@2x) for portrait – Retina 4</p>
<p>iphone4/4s (@2x)   640 x 960 (@2x) for portrait –  2x</p>
<p>第二种方法</p>
<p>使用launchScreen.xib</p>
<p>在xib中拖入一个imageview 设置好约束 上下左右都为0  为imageview添加图片 然后在Images.xcassets中添加相同名字的new image set。在右边将Devices 改为 Device specific</p>
<p>3x 适用于 iphone 6P</p>
<p>Retina 4 2x 适用于 iPhone5s/5</p>
<p>2x 适用于 iphone4s/iphone6 </p>
<p>（不建议使用这种方法，如果同时适配4s和6的话，图片会失真，因为4s和6屏幕的比例不同）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/06/设置appicon和启动图/" data-id="ciedk5cru00023pi07xouwipc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS面试题和参考答案（下篇）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/02/iOS面试题和参考答案（下篇）/" class="article-date">
  <time datetime="2015-09-02T06:24:34.000Z" itemprop="datePublished">2015-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/02/iOS面试题和参考答案（下篇）/">iOS面试题和参考答案（下篇）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a>—参考答案（下）</p>
<p>说明：面试题来源是<a href="http://weibo.com/u/1364395395" target="_blank" rel="external">微博@我就叫Sunny怎么了</a>的这篇博文：<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>
<p>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>
<p>答案为<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a>指正。</p>
<hr>
<p>###25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</p>
<blockquote>
<p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>
</blockquote>
<p>我们可以这样创建一个<code>_objc_msgForward</code>对象：</p>
<pre><code>IMP msgForwardIMP = _objc_msgForward<span class="comment">;</span>
</code></pre><p>在<a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="external">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>
<p>Objective-C运行时是开源的，所以我们可以看到它的实现。打开<a href="http://www.opensource.apple.com/tarballs/objc4/" target="_blank" rel="external"> <strong><em>Apple Open Source 里Mac代码里的obj包</em></strong> </a>下载一个最新版本，找到 <code>objc-runtime-new.mm</code>，进入之后搜索<code>_objc_msgForward</code>。</p>
<p><img src="http://i.imgur.com/rGBfaoL.png" alt="enter image description here"></p>
<p>里面有对<code>_objc_msgForward</code>的功能解释：</p>
<p><img src="http://i.imgur.com/vcThcdA.png" alt="enter image description here"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************&#10;* lookUpImpOrForward.&#10;* The standard IMP lookup. &#10;* initialize==NO tries to avoid +initialize (but sometimes fails)&#10;* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)&#10;* Most callers should use initialize==YES and cache==YES.&#10;* inst is an instance of cls or a subclass thereof, or nil if none is known. &#10;*   If cls is an un-initialized metaclass then a non-nil inst is faster.&#10;* May return _objc_msgForward_impcache. IMPs destined for external use &#10;*   must be converted to _objc_msgForward or _objc_msgForward_stret.&#10;*   If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.&#10;**********************************************************************/</span><br></pre></td></tr></table></figure>
<p>对 <code>objc-runtime-new.mm</code>文件里与<code>_objc_msgForward</code>有关的三个函数使用伪代码展示下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//  objc-runtime-new.mm &#25991;&#20214;&#37324;&#19982; _objc_msgForward &#26377;&#20851;&#30340;&#19977;&#20010;&#20989;&#25968;&#20351;&#29992;&#20266;&#20195;&#30721;&#23637;&#31034;&#10;//  Created by https://github.com/ChenYilong&#10;//  Copyright (c)  &#24494;&#21338;@iOS&#31243;&#24207;&#29357;&#34945;(http://weibo.com/luohanchenyilong/). All rights reserved.&#10;//  &#21516;&#26102;&#65292;&#36825;&#20063;&#26159; obj_msgSend &#30340;&#23454;&#29616;&#36807;&#31243;&#10;&#10;id objc_msgSend(id self, SEL op, ...) &#123;&#10;    if (!self) return nil;&#10;&#9;IMP imp = class_getMethodImplementation(self-&#62;isa, SEL op);&#10;&#9;imp(self, op, ...); //&#35843;&#29992;&#36825;&#20010;&#20989;&#25968;&#65292;&#20266;&#20195;&#30721;...&#10;&#125;&#10; &#10;//&#26597;&#25214;IMP&#10;IMP class_getMethodImplementation(Class cls, SEL sel) &#123;&#10;    if (!cls || !sel) return nil;&#10;    IMP imp = lookUpImpOrNil(cls, sel);&#10;    if (!imp) return _objc_msgForward; //_objc_msgForward &#29992;&#20110;&#28040;&#24687;&#36716;&#21457;&#10;    return imp;&#10;&#125;&#10; &#10;IMP lookUpImpOrNil(Class cls, SEL sel) &#123;&#10;    if (!cls-&#62;initialize()) &#123;&#10;        _class_initialize(cls);&#10;    &#125;&#10; &#10;    Class curClass = cls;&#10;    IMP imp = nil;&#10;    do &#123; //&#20808;&#26597;&#32531;&#23384;,&#32531;&#23384;&#27809;&#26377;&#26102;&#37325;&#24314;,&#20173;&#26087;&#27809;&#26377;&#21017;&#21521;&#29238;&#31867;&#26597;&#35810;&#10;        if (!curClass) break;&#10;        if (!curClass-&#62;cache) fill_cache(cls, curClass);&#10;        imp = cache_getImp(curClass, sel);&#10;        if (imp) break;&#10;    &#125; while (curClass = curClass-&#62;superclass);&#10; &#10;    return imp;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>虽然Apple没有公开<code>_objc_msgForward</code>的实现源码，但是我们还是能得出结论：</p>
<blockquote>
<p><code>_objc_msgForward</code>是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>
<p>在<a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="external">上篇</a>中的《objc中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系？》曾提到<code>objc_msgSend</code>在“消息传递”中的作用。在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>
</blockquote>
<p>为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下<code>_objc_msgForward</code>是如何进行转发的。</p>
<p>首先开启调试模式、打印出所有运行时发送的消息：<br>可以在代码里执行下面的方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(void)instrumentObjcMessageSends(YES);</span><br></pre></td></tr></table></figure>
<p>或者断点暂停程序运行，并在 gdb 中输入下面的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call (void)instrumentObjcMessageSends(YES)</span><br></pre></td></tr></table></figure>
<p>以第二种为例，操作如下所示：</p>
<p><img src="http://i.imgur.com/uEwTCC4.png" alt="enter image description here"></p>
<p>之后，运行时发送的所有消息都会打印到<code>/tmp/msgSend-xxxx</code>文件里了。</p>
<p>终端中输入命令前往：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /private/tmp</span><br></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/Fh5hhCw.png" alt="enter image description here"></p>
<p>可能看到有多条，找到最新生成的，双击打开</p>
<p>在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接：<a href="http://stackoverflow.com/a/10750398/3395008" target="_blank" rel="external"> <strong><em>Can the messages sent to an object in Objective-C be monitored or printed out?</em></strong> </a>），向一个对象发送一条错误的消息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#10;//  main.m&#10;//  CYLObjcMsgForwardTest&#10;//&#10;//  Created by http://weibo.com/luohanchenyilong/.&#10;//  Copyright (c) 2015&#24180; &#24494;&#21338;@iOS&#31243;&#24207;&#29357;&#34945;. All rights reserved.&#10;//&#10;&#10;#import &#60;UIKit/UIKit.h&#62;&#10;#import &#34;AppDelegate.h&#34;&#10;#import &#34;CYLTest.h&#34;&#10;&#10;int main(int argc, char * argv[]) &#123;&#10;    @autoreleasepool &#123;&#10;        CYLTest *test = [[CYLTest alloc] init];&#10;        [test performSelector:(@selector(iOS&#31243;&#24207;&#29357;&#34945;))];&#10;        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/UjbmVvB.png" alt="enter image description here"></p>
<p>你可以在<code>/tmp/msgSend-xxxx</code>（我这一次是<code>/tmp/msgSend-9805</code>）文件里，看到打印出来：</p>
<p><img src="http://i.imgur.com/AAERz1T.png" alt="enter image description here"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ CYLTest NSObject initialize&#10;+ CYLTest NSObject alloc&#10;- CYLTest NSObject init&#10;- CYLTest NSObject performSelector:&#10;+ CYLTest NSObject resolveInstanceMethod:&#10;+ CYLTest NSObject resolveInstanceMethod:&#10;- CYLTest NSObject forwardingTargetForSelector:&#10;- CYLTest NSObject forwardingTargetForSelector:&#10;- CYLTest NSObject methodSignatureForSelector:&#10;- CYLTest NSObject methodSignatureForSelector:&#10;- CYLTest NSObject class&#10;- CYLTest NSObject doesNotRecognizeSelector:&#10;- CYLTest NSObject doesNotRecognizeSelector:&#10;- CYLTest NSObject class</span><br></pre></td></tr></table></figure>
<p>结合<a href="https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11" target="_blank" rel="external">《NSObject官方文档》</a>，排除掉 NSObject 做的事，剩下的就是<code>_objc_msgForward</code>消息转发做的几件事：</p>
<ol>
<li><p>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</p>
</li>
<li><p>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</p>
</li>
<li><p>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</p>
</li>
<li><p>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</p>
</li>
<li><p>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</p>
</li>
</ol>
<p>上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的</p>
<p>也就是说<code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：</p>
<ol>
<li><p><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</p>
</li>
<li><p><code>forwardingTargetForSelector:</code>方法</p>
</li>
<li><p><code>methodSignatureForSelector:</code>方法</p>
</li>
<li><p><code>forwardInvocation:</code>方法</p>
</li>
<li><p><code>doesNotRecognizeSelector:</code> 方法</p>
</li>
</ol>
<p>下面回答下第二个问题“直接<code>_objc_msgForward</code>调用它将会发生什么？”</p>
<p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p>
<p>就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。</p>
<p>正如前文所说：</p>
<blockquote>
<p><code>_objc_msgForward</code>是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</p>
</blockquote>
<p>如何调用<code>_objc_msgForward</code>？<br><code>_objc_msgForward</code>隶属 C 语言，有三个参数 ：</p>
<table>
<thead>
<tr>
<th></th>
<th>–</th>
<th><code>_objc_msgForward</code>参数</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1.</td>
<td>所属对象</td>
<td>id类型</td>
</tr>
<tr>
<td> 2.</td>
<td>方法名</td>
<td>SEL类型 </td>
</tr>
<tr>
<td> 3.</td>
<td>可变参数</td>
<td>可变参数类型</td>
</tr>
</tbody>
</table>
<p>首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式：</p>
<p>为了直观，我们可以通过如下方式定义一个 IMP类型 ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*voidIMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>
<p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p>
<blockquote>
<p>“我没有在这个对象里找到这个方法的实现”</p>
</blockquote>
<p>想象下<code>objc_msgSend</code>会怎么做？通常情况下，下面这张图就是你正常走<code>objc_msgSend</code>过程，和直接调用<code>_objc_msgForward</code>的前后差别：</p>
<p><img src="http://ww1.sinaimg.cn/bmiddle/6628711bgw1eecx3jef23g206404tkbi.gif" alt="enter image description here"></p>
<p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。举例说明：</p>
<p><a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">JSPatch （Github 链接）</a>就是直接调用<code>_objc_msgForward</code>来实现其核心功能的：</p>
<blockquote>
<p> JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。</p>
</blockquote>
<p>作者的博文<a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">《JSPatch实现原理详解》</a>详细记录了实现原理，有兴趣可以看下。</p>
<p>###26. runtime如何实现weak变量的自动置nil？</p>
<blockquote>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
</blockquote>
<p>在<a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="external">上篇</a>中的《runtime 如何实现 weak 属性》有论述。（注：在<a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="external">上篇</a>的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>
<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>
<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>
<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>
<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>
<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>
<p>而如果a是由assign修饰的，则：<br>在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>
<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20351;&#29992;&#20266;&#20195;&#30721;&#27169;&#25311;&#65306;runtime&#22914;&#20309;&#23454;&#29616;weak&#23646;&#24615;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;&#10; id obj1;&#10; objc_initWeak(&#38;obj1, obj);&#10;/*obj&#24341;&#29992;&#35745;&#25968;&#21464;&#20026;0&#65292;&#21464;&#37327;&#20316;&#29992;&#22495;&#32467;&#26463;*/&#10; objc_destroyWeak(&#38;obj1);</span><br></pre></td></tr></table></figure>
<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>
<p>总体说来，作用是：<br>通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>
<p>下面分别介绍下方法的内部实现：</p>
<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj1 = 0&#65307;&#10;obj_storeWeak(&#38;obj1, obj);</span><br></pre></td></tr></table></figure>
<p>也就是说：</p>
<blockquote>
<p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>
</blockquote>
<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>
<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>
<p>前面的源代码与下列源代码相同。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20351;&#29992;&#20266;&#20195;&#30721;&#27169;&#25311;&#65306;runtime&#22914;&#20309;&#23454;&#29616;weak&#23646;&#24615;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;&#10;id obj1;&#10;obj1 = 0;&#10;objc_storeWeak(&#38;obj1, obj);&#10;/* ... obj&#30340;&#24341;&#29992;&#35745;&#25968;&#21464;&#20026;0&#65292;&#34987;&#32622;nil ... */&#10;objc_storeWeak(&#38;obj1, 0);</span><br></pre></td></tr></table></figure>
<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。</p>
<p>###27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ </p>
<ul>
<li>不能向编译后得到的类中增加实例变量；</li>
<li>能向运行时创建的类中添加实例变量；</li>
</ul>
<p>解释下：</p>
<ul>
<li><p>因为编译后的类已经注册在 runtime 中，类结构体中的 <code>objc_ivar_list</code> 实例变量的链表 和 <code>instance_size</code> 实例变量的内存大小已经确定，同时runtime 会调用 <code>class_setIvarLayout</code> 或 <code>class_setWeakIvarLayout</code> 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p>
</li>
<li><p>运行时创建的类是可以添加实例变量，调用 <code>class_addIvar</code> 函数。但是得在调用 <code>objc_allocateClassPair</code> 之后，<code>objc_registerClassPair</code> 之前，原因同上。</p>
</li>
</ul>
<p>###28. runloop和线程有什么关系？</p>
<p>总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>
<p> runloop 和线程的关系：</p>
<ol>
<li><p>主线程的run loop默认是启动的。</p>
<p>iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;&#10;    @autoreleasepool &#123;&#10;        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
</li>
<li><p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p>
</li>
<li><p>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p>
</li>
</ol>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="http://blog.csdn.net/wzzvictory/article/details/9237973" target="_blank" rel="external">《Objective-C之run loop详解》</a>。</p>
<p>###29. runloop的mode作用是什么？</p>
<p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView滑动时</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>
<p>苹果公开提供的 Mode 有两个：</p>
<ol>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>
</ol>
<p>###30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</p>
<p>RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响scrllView的滑动。</p>
<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,<br>ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>
<p>同时因为mode还是可定制的，所以：</p>
<p> Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#10;// http://weibo.com/luohanchenyilong/ (&#24494;&#21338;@iOS&#31243;&#24207;&#29357;&#34945;)&#10;// https://github.com/ChenYilong&#10;&#10;//&#23558;timer&#28155;&#21152;&#21040;NSDefaultRunLoopMode&#20013;&#10;[NSTimer scheduledTimerWithTimeInterval:1.0&#10;     target:self&#10;     selector:@selector(timerTick:)&#10;     userInfo:nil&#10;     repeats:YES];&#10;//&#28982;&#21518;&#20877;&#28155;&#21152;&#21040;NSRunLoopCommonModes&#37324;&#10;NSTimer *timer = [NSTimer timerWithTimeInterval:1.0&#10;     target:self&#10;     selector:@selector(timerTick:)&#10;     userInfo:nil&#10;     repeats:YES];&#10;[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<p>###31. 猜想runloop内部是如何实现的？</p>
<blockquote>
<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑<br>是这样的：</p>
</blockquote>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> {</span>
    initialize<span class="params">()</span>;
    do {
        var message = get_next_message<span class="params">()</span>;
        process_message<span class="params">(message)</span>;
    } while <span class="params">(message != quit)</span>;
}
</code></pre><p>或使用伪代码来展示下:</p>
<pre><code><span class="comment">// </span>
<span class="comment">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]</span>) </span>{
 <span class="comment">//程序一直运行状态</span>
 <span class="keyword">while</span> (AppIsRunning) {
      <span class="comment">//睡眠状态，等待唤醒事件</span>
      id whoWakesMe = SleepForWakingUp();
      <span class="comment">//得到唤醒事件</span>
      id <span class="keyword">event</span> = GetEvent(whoWakesMe);
      <span class="comment">//开始处理事件</span>
      HandleEvent(<span class="keyword">event</span>);
 }
 <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>参考链接：</p>
<ol>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="external">《深入理解RunLoop》</a></li>
<li>摘自博文<a href="https://github.com/ming1016/study/wiki/CFRunLoop" target="_blank" rel="external"><strong><em>CFRunLoop</em></strong></a>，原作者是<a href="http://weibo.com/u/1364395395" target="_blank" rel="external">微博@我就叫Sunny怎么了</a></li>
</ol>
<p>###32. objc使用什么机制管理对象内存？</p>
<p>通过 retainCount 的机制来决定对象是否需要释放。<br>每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>
<p>###33. ARC通过什么方式帮助开发者管理内存？<br>编译时根据代码上下文，插入 retain/release</p>
<p>###34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）<br>分两种情况：手动干预释放时机、系统自动去释放。</p>
<ol>
<li>手动干预释放时机–指定autoreleasepool<br>就是所谓的：当前作用域大括号结束时释放。</li>
<li><p>系统自动去释放–不手动指定autoreleasepool</p>
<p>Autorelease对象会在当前的 runloop 迭代结束时释放。</p>
<p>如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</p>
</li>
</ol>
<p>参考链接：<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">《黑幕背后的Autorelease》</a></p>
<p>###35. BAD_ACCESS在什么情况下出现？<br>访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。<br>死循环</p>
<p>###36. 苹果是如何实现autoreleasepool的？ </p>
<p>autoreleasepool以一个队列数组的形式实现,主要通过下列三个函数完成.</p>
<ol>
<li><code>objc_autoreleasepoolPush</code></li>
<li><code>objc_autoreleasepoolPop</code></li>
<li><code>objc_aurorelease</code></li>
</ol>
<p>看函数名就可以知道，对autorelease分别执行push，和pop操作。销毁对象时执行release操作。</p>
<p>###37. 使用block时什么情况会发生引用循环，如何解决？<br>一个对象中强引用了block，在block中又使用了该对象，就会发射循环引用。<br>解决方法是将该对象使用<strong>weak或者</strong>block修饰符修饰之后再在block中使用。</p>
<ol>
<li>id weak weakSelf = self;<br>或者 weak __typeof(&amp;*self)weakSelf = self该方法可以设置宏</li>
<li>id __block weakSelf = self;</li>
</ol>
<p>###38. 在block内如何修改block外部变量？<br>默认情况下，在block中访问的外部变量是复制过去的，即：<strong>写操作不对原变量生效</strong>。但是你可以加上<code>__block</code>来让其写操作生效，示例代码如下:</p>
<pre><code>__block <span class="keyword">int</span> a = <span class="number">0</span>;
<span class="keyword">void</span>  (^foo)(<span class="keyword">void</span>) = ^{ 
    a = <span class="number">1</span>; 
}
f00(); 
<span class="comment">//这里，a的值被修改为1</span>
</code></pre><p>参考链接：<a href="http://weibo.com/tangqiaoboy" target="_blank" rel="external">微博@唐巧_boy</a>的著作《iOS开发进阶》中的第11.2.3章节</p>
<p>###39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ </p>
<p>系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：</p>
<p>所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:duration animations:^&#123; [self.superview layoutIfNeeded]; &#125;];</span><br></pre></td></tr></table></figure>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.someProperty = xyz; &#125;];</span><br></pre></td></tr></table></figure>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserverForName:@&#34;someNotification&#34; &#10;                                                  object:nil &#10;                           queue:[NSOperationQueue mainQueue]&#10;                                              usingBlock:^(NSNotification * notification) &#123;&#10;                                                    self.someProperty = xyz; &#125;];</span><br></pre></td></tr></table></figure>
<p>这些情况不需要考虑“引用循环”。</p>
<p>但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof__(self) weakSelf = self;&#10;dispatch_group_async(_operationsGroup, _operationsQueue, ^&#10;&#123;&#10;__typeof__(self) strongSelf = weakSelf;&#10;[strongSelf doSomething];&#10;[strongSelf doSomethingElse];&#10;&#125; );</span><br></pre></td></tr></table></figure>
<p>类似的：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof__(self) weakSelf = self;&#10;_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&#34;testKey&#34;&#10;                                                              object:nil&#10;                                                               queue:nil&#10;                                                          usingBlock:^(NSNotification *note) &#123;&#10;    __typeof__(self) strongSelf = weakSelf;&#10;    [strongSelf dismissModalViewControllerAnimated:YES];&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>self –&gt; _observer –&gt; block –&gt; self 显然这也是一个循环引用。</p>
<p>###40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</p>
<ol>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ol>
<p>###41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</p>
<p>使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&#10;dispatch_group_t group = dispatch_group_create();&#10;dispatch_group_async(group, queue, ^&#123; /*&#21152;&#36733;&#22270;&#29255;1 */ &#125;);&#10;dispatch_group_async(group, queue, ^&#123; /*&#21152;&#36733;&#22270;&#29255;2 */ &#125;);&#10;dispatch_group_async(group, queue, ^&#123; /*&#21152;&#36733;&#22270;&#29255;3 */ &#125;); &#10;dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;&#10;        // &#21512;&#24182;&#22270;&#29255;&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>###42. <code>dispatch_barrier_async</code>的作用是什么？<br> 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。<br> <code>dispatch_barrier_async</code> 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 <code>dispatch_barrier_async</code> 函数追加的处理，等 <code>dispatch_barrier_async</code> 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。</p>
<p>打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 <code>dispatch_barrier_async</code> 函数追加的内容就如同 “上完厕所就上高速”这个动作。</p>
<p>###43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</p>
<p><code>dispatch_get_current_queue</code>容易造成死锁</p>
<p>###44. 以下代码运行结果如何？</p>
<pre><code>- (void)viewDidLoad
{
    <span class="attr_selector">[super viewDidLoad]</span>;
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"1"</span>);</span>
    <span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
        <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"2"</span>);</span>
    });
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"3"</span>);</span>
}
</code></pre><p>只输出：1 。发生主线程锁死。</p>
<p>###45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#28155;&#21152;&#38190;&#20540;&#35266;&#23519;&#10;/*&#10;1 &#35266;&#23519;&#32773;&#65292;&#36127;&#36131;&#22788;&#29702;&#30417;&#21548;&#20107;&#20214;&#30340;&#23545;&#35937;&#10;2 &#35266;&#23519;&#30340;&#23646;&#24615;&#10;3 &#35266;&#23519;&#30340;&#36873;&#39033;&#10;4 &#19978;&#19979;&#25991;&#10;*/&#10;[self.person addObserver:self forKeyPath:@&#34;name&#34; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&#34;Person Name&#34;];</span><br></pre></td></tr></table></figure>
<p>observer中需要实现一下方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#25152;&#26377;&#30340; kvo &#30417;&#21548;&#21040;&#20107;&#20214;&#65292;&#37117;&#20250;&#35843;&#29992;&#27492;&#26041;&#27861;&#10;/*&#10; 1. &#35266;&#23519;&#30340;&#23646;&#24615;&#10; 2. &#35266;&#23519;&#30340;&#23545;&#35937;&#10; 3. change &#23646;&#24615;&#21464;&#21270;&#23383;&#20856;&#65288;&#26032;&#65295;&#26087;&#65289;&#10; 4. &#19978;&#19979;&#25991;&#65292;&#19982;&#30417;&#21548;&#30340;&#26102;&#20505;&#20256;&#36882;&#30340;&#19968;&#33268;&#10; */&#10;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</span><br></pre></td></tr></table></figure>
<p>###46. 如何手动触发一个value的KVO</p>
<p>所谓的“手动触发”是区别于“自动触发”：</p>
<p>自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。</p>
<p>想知道如何手动触发，必须知道自动触发 KVO 的原理：</p>
<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就<br>会记录旧的值。而当改变发生后，  <code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>
<p>那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。</p>
<p>具体做法如下：</p>
<p>如果这个  <code>value</code> 是  表示时间的 <code>self.now</code> ，那么代码如下：最后两行代码缺一不可。</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//  .m&#25991;&#20214;&#10;//  Created by https://github.com/ChenYilong&#10;//  &#24494;&#21338;@iOS&#31243;&#24207;&#29357;&#34945;(http://weibo.com/luohanchenyilong/).&#10;//  &#25163;&#21160;&#35302;&#21457; value &#30340;KVO&#65292;&#26368;&#21518;&#20004;&#34892;&#20195;&#30721;&#32570;&#19968;&#19981;&#21487;&#12290;&#10;&#10;//@property (nonatomic, strong) NSDate *now;&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;    [self willChangeValueForKey:@&#34;now&#34;]; // &#8220;&#25163;&#21160;&#35302;&#21457;self.now&#30340;KVO&#8221;&#65292;&#24517;&#20889;&#12290;&#10;    [self didChangeValueForKey:@&#34;now&#34;]; // &#8220;&#25163;&#21160;&#35302;&#21457;self.now&#30340;KVO&#8221;&#65292;&#24517;&#20889;&#12290;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>
<blockquote>
<p>比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、 <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。</p>
</blockquote>
<p>大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到人们这么写代码:</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNow:(NSDate *)aDate &#123;&#10;    [self willChangeValueForKey:@&#34;now&#34;]; // &#27809;&#26377;&#24517;&#35201;&#10;    _now = aDate;&#10;    [self didChangeValueForKey:@&#34;now&#34;];// &#27809;&#26377;&#24517;&#35201;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 <code>willChangeValueForKey:</code>  ，之后总是调用 <code>didChangeValueForkey:</code> 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。</p>
<p>###47. 若一个类有实例变量 <code>NSString *_foo</code> ，调用setValue:forKey:时，可以以foo还是 <code>_foo</code> 作为key？<br>都可以。</p>
<p>###48. KVC的keyPath中的集合运算符如何使用？</p>
<ol>
<li>必须用在集合对象上或普通对象的集合属性上</li>
<li>简单集合运算符有@avg， @count ， @max ， @min ，@sum，</li>
<li>格式 @”@sum.age”或 @”集合属性.@max.age”</li>
</ol>
<p>###49. KVC和KVO的keyPath一定是属性么？<br>KVO支持实例变量</p>
<p>###50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</p>
<p>请参考：<a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="external">《如何自己动手实现 KVO》</a></p>
<p>###51. apple用什么方式实现对一个对象的KVO？ </p>
<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Apple 的文档</a>对 KVO 实现的描述：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>
</blockquote>
<p>从<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Apple 的文档</a>可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：</p>
<blockquote>
<p>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：</p>
</blockquote>
<p><img src="http://i62.tinypic.com/sy57ur.jpg" alt="enter image description here"></p>
<p> KVO 确实有点黑魔法：</p>
<blockquote>
<p>Apple 使用了 <code>isa 混写（isa-swizzling）</code>来实现 KVO 。</p>
</blockquote>
<p>下面做下详细解释：</p>
<p>键值观察通知依赖于 NSObject 的两个方法:  <code>willChangeValueForKey:</code> 和 <code>didChangevlueForKey:</code> 。在一个被观察属性发生改变之前，  <code>willChangeValueForKey:</code> 一定会被调用，这就<br>会记录旧的值。而当改变发生后，  <code>didChangeValueForKey:</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code> 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。</p>
<p> 比如调用 <code>setNow:</code> 时，系统还会以某种方式在中间插入 <code>wilChangeValueForKey:</code> 、 <code>didChangeValueForKey:</code>  和 <code>observeValueForKeyPath:ofObject:change:context:</code> 的调用。大家可能以为这是因为 <code>setNow:</code> 是合成方法，有时候我们也能看到人们这么写代码:</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNow:(NSDate *)aDate &#123;&#10;    [self willChangeValueForKey:@&#34;now&#34;]; // &#27809;&#26377;&#24517;&#35201;&#10;    _now = aDate;&#10;    [self didChangeValueForKey:@&#34;now&#34;];// &#27809;&#26377;&#24517;&#35201;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 <code>willChangeValueForKey:</code>  ，之后总是调用 <code>didChangeValueForkey:</code> 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用 <code>addObserver:forKeyPath:options:context:</code> 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNow:(NSDate *)aDate &#123;&#10;    [self willChangeValueForKey:@&#34;now&#34;];&#10;    [super setValue:aDate forKey:@&#34;now&#34;];&#10;    [self didChangeValueForKey:@&#34;now&#34;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。</p>
<p>KVO 在实现中通过 <code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">Apple 的文档</a>可以得到印证：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>
</blockquote>
<p>然而 KVO 在实现中使用了 <code>isa 混写（ isa-swizzling）</code> ，这个的确不是很容易发现：Apple 还重写、覆盖了 <code>-class</code> 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。</p>
<p>但是，假设“被监听的对象”的类对象是 <code>MYClass</code> ，有时候我们能看到对 <code>NSKVONotifying_MYClass</code> 的引用而不是对  <code>MYClass</code>  的引用。借此我们得以知道 Apple 使用了 <code>isa 混写（isa-swizzling）</code>。具体探究过程可参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external"> 这篇博文 </a>。</p>
<p>###52. IBOutlet连出来的视图属性为什么可以被设置成weak?</p>
<p>参考链接：<a href="http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc" target="_blank" rel="external"> <strong><em>Should IBOutlets be strong or weak under ARC?</em></strong> </a></p>
<p>文章告诉我们：</p>
<blockquote>
<p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。</p>
</blockquote>
<p>不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系</p>
<p>###53. IB中User Defined Runtime Attributes如何使用？ </p>
<p>它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller</p>
<p>###54. 如何调试BAD_ACCESS错误</p>
<ol>
<li>重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object</li>
<li><p>通过 Zombie<br><img src="http://i.stack.imgur.com/ZAdi0.png" alt="enter image description here"></p>
</li>
<li><p>设置全局断点快速定位问题代码所在行</p>
</li>
<li>Xcode 7 已经集成了BAD_ACCESS捕获功能：<strong>Address Sanitizer</strong>。<br>用法如下：在配置中勾选✅Enable Address Sanitizer<br><img src="https://developer.apple.com/library/prerelease/ios/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Art/xc7-asan_2x.png" alt="enter image description here"></li>
</ol>
<p>###55. lldb（gdb）常用的调试命令？</p>
<ul>
<li>breakpoint 设置断点定位到某一个函数</li>
<li>n 断点指针下一步</li>
<li>po打印对象</li>
</ul>
<p>更多 lldb（gdb） 调试命令可查看</p>
<ol>
<li><a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external"> <strong><em>The LLDB Debugger</em></strong> </a>；</li>
<li>苹果官方文档：<a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html" target="_blank" rel="external"> <strong><em>iOS Debugging Magic</em></strong> </a>。</li>
</ol>
<hr>
<p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="external">Creative Commons BY-NC-ND 3.0</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/02/iOS面试题和参考答案（下篇）/" data-id="ciedk5cry00043pi0bvabiuni" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS面试题和参考答案（上篇）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/02/iOS面试题和参考答案（上篇）/" class="article-date">
  <time datetime="2015-09-02T06:22:46.000Z" itemprop="datePublished">2015-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/02/iOS面试题和参考答案（上篇）/">iOS面试题和参考答案（上篇）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a>—参考答案（上）</p>
<p>说明：面试题来源是<a href="http://weibo.com/u/1364395395" target="_blank" rel="external">微博@我就叫Sunny怎么了</a>的这篇博文：<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a>，其中共55题，除第一题为纠错题外，其他54道均为简答题。</p>
<p>出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>
<p>答案为<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a>整理，未经出题者校对，如有纰漏，请向<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a>指正。</p>
<hr>
<p>###1. 风格纠错题<br><img src="http://i.imgur.com/O7Zev94.png" alt="enter image description here"><br>修改完的代码：</p>
<p>修改方法有很多种，现给出一种做示例：</p>
<pre><code><span class="comment">// .h文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法</span>

<span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

<span class="class"><span class="keyword">@interface</span> <span class="title">CYLUser</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCopying</span>&gt;</span>

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) CYLSex sex;

- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;

<span class="keyword">@end</span>
</code></pre><p>下面对具体修改的地方，分两部分做下介绍：<strong><em>硬伤部分</em></strong>和<strong><em>优化部分</em></strong><br>。因为<strong><em>硬伤部分</em></strong>没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看<strong><em>优化部分</em></strong>。</p>
<p>####<strong><em>优化部分</em></strong></p>
<ol>
<li><p>enum建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html" target="_blank" rel="external">Adopting Modern Objective-C</a> 一文：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#23450;&#20041;&#19968;&#20010;&#26522;&#20030;&#10;&#9;typedef NS_ENUM(NSInteger, CYLSex) &#123;&#10;&#9;    CYLSexMan,&#10;&#9;    CYLSexWoman&#10;&#9;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>age属性的类型：应避免使用基本类型，建议使Foundation数据类型，对应关系如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int -&#62; NSInteger&#10;unsigned -&#62; NSUInteger&#10;float -&#62; CGFloat&#10;&#21160;&#30011;&#26102;&#38388; -&#62; NSTimeInterval</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>同时考虑到age的特点，应使用NSUInteger，而非int。<br>这样做的是基于64-bit 适配考虑，详情可参考出题者的博文<a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/" target="_blank" rel="external">《64-bit Tips》</a>。</p>
<ol>
<li>如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。</li>
<li>doLogIn方法不应写在该类中：虽然<code>LogIn</code>的命名不太清晰，但笔者猜测是login的意思，而登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”：</li>
</ol>
<blockquote>
<p>无论是MVC模式还是MVVM模式，业务逻辑都不应当写在Model里。</p>
</blockquote>
<p> （如果抛开命名规范，假设该类真的是MVVM模式里的 ViewModel ，那么UserModel这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如：login对应的应当是注册并登录的一个Button，出现login方法也可能是合理的。）</p>
<ol>
<li><p>doLogIn方法命名不规范：添加了多余的动词前缀。<br>请牢记：</p>
<blockquote>
<p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用<code>do</code>，<code>does</code>这种多余的关键字，动词本身的暗示就足够了。</p>
</blockquote>
</li>
<li><p><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中不要用<code>with</code>来连接两个参数:<code>withAge:</code>应当换为<code>age:</code>，<code>age:</code>已经足以清晰说明参数的作用，也不建议用<code>andAge:</code>：通常情况下，即使有类似<code>withA:withB:</code>的命名需求，也通常是使用<code>withA:andB:</code>这种命名，用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候也可以拆分成两个独立的方法</em>），它不应该用作阐明有多个参数，比如下面的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#38169;&#35823;&#65292;&#19981;&#35201;&#20351;&#29992;&#34;and&#34;&#26469;&#36830;&#25509;&#21442;&#25968;&#10;- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;&#10;//&#38169;&#35823;&#65292;&#19981;&#35201;&#20351;&#29992;&#34;and&#34;&#26469;&#38416;&#26126;&#26377;&#22810;&#20010;&#21442;&#25968;&#10;- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;&#10;//&#27491;&#30830;&#65292;&#20351;&#29992;&#34;and&#34;&#26469;&#34920;&#31034;&#20004;&#20010;&#30456;&#23545;&#29420;&#31435;&#30340;&#25805;&#20316;&#10;- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为copy。(原因在下文有详细论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？</em></strong>)</p>
</li>
<li><p>“性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？</p>
<p>Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明：</p>
</li>
</ol>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;// .m&#25991;&#20214;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;//&#10;&#10;@implementation CYLUser&#10;&#10;- (instancetype)initWithName:(NSString *)name&#10;                         age:(NSUInteger)age&#10;                         sex:(CYLSex)sex &#123;&#10;    if(self = [super init]) &#123;&#10;        _name = [name copy];&#10;        _age = age;&#10;        _sex = sex;&#10;    &#125;&#10;    return self;&#10;&#125;&#10;&#10;- (instancetype)initWithName:(NSString *)name&#10;                         age:(NSUInteger)age &#123;&#10;    return [self initWithName:name age:age sex:nil];&#10;&#125;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p> 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。</p>
<p>  因为出题者没有给出.m文件，所以有两种猜测：1：本来打算只设计一个designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为readwrite属性，最终给出的修改代码应该是：</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#10;// .h&#25991;&#20214;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;// &#31532;&#20108;&#31181;&#20462;&#25913;&#26041;&#27861;&#65288;&#22522;&#20110;&#31532;&#19968;&#31181;&#20462;&#25913;&#26041;&#27861;&#30340;&#22522;&#30784;&#19978;&#65289;&#10;&#10;typedef NS_ENUM(NSInteger, CYLSex) &#123;&#10;    CYLSexMan,&#10;    CYLSexWoman&#10;&#125;;&#10;&#10;@interface CYLUser : NSObject&#60;NSCopying&#62;&#10;&#10;@property (nonatomic, readonly, copy) NSString *name;&#10;@property (nonatomic, readonly, assign) NSUInteger age;&#10;@property (nonatomic, readwrite, assign) CYLSex sex;&#10;&#10;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;&#10;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;&#10;+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;&#10;&#10;@end</span><br></pre></td></tr></table></figure>
<p> .h中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳–》 <a href="http://is.gd/OQ49zk" target="_blank" rel="external"><strong><em>《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》</em></strong></a>。）</p>
<ol>
<li>按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为instancetype，为保持一致性，init方法和快捷构造方法的返回类型最好都用instancetype。</li>
<li><p>如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:<br>那么在设计对应@property时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样</p>
<pre><code><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInter</span> age;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) CYLSex sex;
</code></pre><p>  由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。</p>
</li>
<li><code>initUserModelWithUserName</code>如果改为<code>initWithName</code>会更加简洁，而且足够清晰。</li>
<li><code>UserModel</code>如果改为<code>User</code>会更加简洁，而且足够清晰。</li>
<li><code>UserSex</code>如果改为<code>Sex</code>会更加简洁，而且足够清晰。</li>
<li><p>第二个@property中assign和nonatomic调换位置。<br>推荐按照下面的格式来定义属性</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readwrite, copy) NSString *name;</span><br></pre></td></tr></table></figure>
<p>属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。这在<a href="https://github.com/oa414/objc-zen-book-cn#属性定义" target="_blank" rel="external">《禅与Objective-C编程艺术 &gt;》</a>里有介绍。而且习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作。</p>
</li>
</ol>
<p>####<strong><em>硬伤部分</em></strong></p>
<ol>
<li>在-和(void)之间应该有一个空格</li>
<li>enum中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。</li>
<li>enum左括号前加一个空格，或者将左括号换到下一行</li>
<li>enum右括号后加一个空格</li>
<li><code>UserModel :NSObject</code> 应为<code>UserModel : NSObject</code>，也就是<code>:</code>右侧少了一个空格。</li>
<li>@interface与@property属性声明中间应当间隔一行。</li>
<li>两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。</li>
<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中方法名与参数之间多了空格。而且<code>-</code> 与<code>(id)</code>之间少了空格。</li>
<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中方法名与参数之间多了空格：<code>(NSString*)name</code>前多了空格。</li>
<li><code>-(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;</code>方法中<code>(NSString*)name</code>,应为<code>(NSString *)name</code>，少了空格。 </li>
<li>doLogIn方法命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。</li>
</ol>
<p>###2. 什么情况使用 weak 关键字，相比 assign 有什么不同？<br>什么情况使用 weak 关键字？</p>
<ol>
<li><p>在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性</p>
</li>
<li><p>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。在下文也有论述：<strong><em>《IBOutlet连出来的视图属性为什么可以被设置成weak?》</em></strong></p>
</li>
</ol>
<p>不同点：</p>
<ol>
<li><p><code>weak</code> 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，<br>然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。<br>而 <code>assign</code> 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或<br>NSlnteger 等)的简单赋值操作。</p>
</li>
<li><p>assigin 可以用非OC对象,而weak必须用于OC对象</p>
</li>
</ol>
<p>###3. 怎么用 copy 关键字？<br>用途：</p>
<ol>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li><p>block也经常使用copy关键字，具体原因见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12" target="_blank" rel="external">官方文档：<strong><em>Objects Use Properties to Keep Track of Blocks</em></strong></a>：</p>
<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在ARC中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</p>
<p><img src="http://i.imgur.com/VlVKl8L.png" alt="enter image description here"></p>
</li>
</ol>
<p>下面做下解释：<br>copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
<blockquote>
<p>用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
</blockquote>
<p>该问题在下文中也有论述：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong></p>
<p>###4. 这个写法会出什么问题： <code>@property (copy) NSMutableArray *array;</code><br>两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为copy就是复制一个不可变NSArray的对象；2、使用了atomic属性会严重影响性能 ； </p>
<p>第1条的相关原因在下文中有论述<strong><em>《用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？》</em></strong> 以及上文<strong><em>《怎么用 copy 关键字？》</em></strong>也有论述。</p>
<p>比如下面的代码就会发生崩溃</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// .h&#25991;&#20214;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;// &#19979;&#38754;&#30340;&#20195;&#30721;&#23601;&#20250;&#21457;&#29983;&#23849;&#28291;&#10;&#10;@property (nonatomic, copy) NSMutableArray *mutableArray;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// .m&#25991;&#20214;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;// &#19979;&#38754;&#30340;&#20195;&#30721;&#23601;&#20250;&#21457;&#29983;&#23849;&#28291;&#10;&#10;NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];&#10;self.mutableArray = array;&#10;[self.mutableArray removeObjectAtIndex:0];</span><br></pre></td></tr></table></figure>
<p>接下来就会奔溃：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</span><br></pre></td></tr></table></figure>
<p>第2条原因，如下：</p>
<blockquote>
<p>该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销。</p>
</blockquote>
<p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备nonatomic特质，那它就是“原子的”(atomic))。</p>
<p>在iOS开发中，你会发现，几乎所有属性都声明为nonatomic。</p>
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。</p>
<p>因此，开发iOS程序时一般都会使用nonatomic属性。但是在开发Mac OS X程序时，使用<br>atomic属性通常都不会有性能瓶颈。</p>
<p>###5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</p>
<blockquote>
<p>若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopyiog与NSMutableCopying协议。</p>
</blockquote>
<p>具体步骤：</p>
<ol>
<li>需声明该类遵从NSCopying协议</li>
<li><p>实现NSCopying协议。该协议只有一个方法: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone: (NSZone*) zone</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是“copyWithZone”方法。</p>
<p>以第一题的代码为例：</p>
<pre><code><span class="comment">// .h文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 修改完的代码</span>

<span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

<span class="class"><span class="keyword">@interface</span> <span class="title">CYLUser</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCopying</span>&gt;</span>

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) CYLSex sex;

- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;

<span class="keyword">@end</span>
</code></pre><p>然后实现协议中规定的方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;&#10;&#9;CYLUser *copy = [[[self class] allocWithZone:zone] &#10;&#9;&#9;             initWithName:_name&#10; &#9;&#9;&#9;&#9;&#9;&#9;&#9;      age:_age&#10;&#9;&#9;&#9;&#9;&#9;&#9;          sex:_sex];&#10;&#9;return copy;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如CYLUser中含有一个数组，与其他CYLUser对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:</p>
<pre><code><span class="comment">// .h文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 以第一题《风格纠错题》里的代码为例</span>

<span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

<span class="class"><span class="keyword">@interface</span> <span class="title">CYLUser</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCopying</span>&gt;</span>

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) CYLSex sex;

- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSUInteger</span>)age sex:(CYLSex)sex;
- (<span class="keyword">void</span>)addFriend:(CYLUser *)user;
- (<span class="keyword">void</span>)removeFriend:(CYLUser *)user;

<span class="keyword">@end</span>
</code></pre><p>// .m文件</p>
<pre><code><span class="comment">// .m文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// </span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">CYLUser</span> </span>{
    <span class="built_in">NSMutableSet</span> *_friends;
}

- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name {
    _name = [name <span class="keyword">copy</span>];
}

- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name 
                             age:(<span class="built_in">NSUInteger</span>)age 
                             sex:(CYLSex)sex {
     <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
         _name = [name <span class="keyword">copy</span>];
         _age = age;
         _sex = sex;
         _friends = [[<span class="built_in">NSMutableSet</span> alloc] init];
     }
     <span class="keyword">return</span> <span class="keyword">self</span>;
}

- (<span class="keyword">void</span>)addFriend:(CYLUser *)user {
    [_friends addObject:user];
}

- (<span class="keyword">void</span>)removeFriend:(CYLUser *)user {
    [_friends removeObject:person];
}

- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone {
    CYLUser *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> class] allocWithZone:zone] 
                     initWithName:_name
                                   age:_age
                                  sex:_sex];
    <span class="keyword">copy</span>-&gt;_friends = [_friends mutableCopy];
    <span class="keyword">return</span> <span class="keyword">copy</span>;
}

- (<span class="keyword">id</span>)deepCopy {
    CYLUser *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> class] allocWithZone:zone] 
                     initWithName:_name
                                   age:_age
                                  sex:_sex];
    <span class="keyword">copy</span>-&gt;_friends = [[<span class="built_in">NSMutableSet</span> alloc] initWithSet:_friends 
                                             copyItems:<span class="literal">YES</span>];
    <span class="keyword">return</span> <span class="keyword">copy</span>;
}

<span class="keyword">@end</span>
</code></pre><p>以上做法能满足基本的需求，但是也有缺陷：</p>
<blockquote>
<p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p>
</blockquote>
<p>【注：深浅拷贝的概念，在下文中有介绍，详见下文的：<strong><em>用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</em></strong>】</p>
<p>在例子中，存放朋友对象的set是用“copyWithZone:”方法来拷贝的，这种浅拷贝方式不会逐个复制set中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:</p>
<pre><code>- (<span class="keyword">id</span>)deepCopy {
    CYLUser *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> class] allocWithZone:zone] 
                     initWithName:_name
                                   age:_age
                                  sex:_sex];
    <span class="keyword">copy</span>-&gt;_friends = [[<span class="built_in">NSMutableSet</span> alloc] initWithSet:_friends 
                                             copyItems:<span class="literal">YES</span>];
    <span class="keyword">return</span> <span class="keyword">copy</span>;
}
</code></pre><p>至于<strong><em>如何重写带 copy 关键字的 setter</em></strong>这个问题，</p>
<p>如果抛开本例来回答的话，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name &#123;&#10;    //[_name release];&#10;    _name = [name copy];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”</p>
<pre><code>- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name {
    <span class="keyword">if</span> (_name != name) {
    <span class="comment">//[_name release];//MRC</span>
    _name = [name <span class="keyword">copy</span>];
    }
}
</code></pre><p>这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法：</p>
<p><img src="http://i.imgur.com/UwV9oSn.jpeg" alt="enter image description here"></p>
<p>克强总理这样评价你的代码风格：</p>
<p><img src="http://i.imgur.com/N77Lkic.png" alt="enter image description here"></p>
<p>我和总理的意见基本一致：</p>
<blockquote>
<p>老百姓 copy 一下，咋就这么难？</p>
</blockquote>
<p>你可能会说：</p>
<p>之所以在这里做<code>if判断</code> 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。<br>(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)</p>
<p>但是你有没有考虑过代价：</p>
<blockquote>
<p>你每次调用<code>setX:</code>都会做 if 判断，这会让<code>setX:</code>变慢，如果你在<code>setX:</code>写了一串复杂的 <code>if+elseif+elseif+...</code> 判断，将会更慢。</p>
</blockquote>
<p>要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a setX:x1];&#10;[a setX:x1];    //&#20320;&#30830;&#23450;&#20320;&#35201;&#36825;&#20040;&#24178;&#65311;&#19982;&#20854;&#22312;setter&#20013;&#21028;&#26029;&#65292;&#20026;&#20160;&#20040;&#19981;&#25226;&#20195;&#30721;&#20889;&#22909;&#65311;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a setX:[a x]];   //&#38431;&#21451;&#21638;&#21742;&#36947;&#65306;&#20320;&#22312;&#24178;&#22043;&#65311;&#65281;&#65281;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要在setter里进行像<code>if(_obj != newObj)</code>这样的判断。（该观点参考链接：<a href="http://vgable.com/blog/tag/autorelease/" target="_blank" rel="external"> <strong><em>How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure</em></strong> </a><br>）</p>
</blockquote>
<p>什么情况会在 copy setter 里做 if 判断？<br>例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)setSpeed:(int)_speed&#123;&#10;    if(_speed &#60; 0) speed = 0;&#10;    if(_speed &#62; 300) speed = 300;&#10;    _speed = speed;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写name的 setter ：由于是name是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”–copy，是因为：如果不写copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效。）。</p>
<p>那如何确保name被copy？在初始化方法(initializer)中做：</p>
<pre><code>- (instancetype)initWithName:(<span class="built_in">NSString</span> *)name 
                             age:(<span class="built_in">NSUInteger</span>)age 
                             sex:(CYLSex)sex {
     <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
         _name = [name <span class="keyword">copy</span>];
         _age = age;
         _sex = sex;
         _friends = [[<span class="built_in">NSMutableSet</span> alloc] init];
     }
     <span class="keyword">return</span> <span class="keyword">self</span>;
}
</code></pre><p>###6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</p>
<p><strong>@property 的本质是什么？</strong></p>
<blockquote>
<p>@property = ivar + getter + setter;</p>
</blockquote>
<p>下面解释下：</p>
<blockquote>
<p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</p>
</blockquote>
<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为<code>Objective-C 2.0</code>的一部分。<br>而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。<br>正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</p>
<blockquote>
<p>编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。<br>所以你也可以这么说：</p>
<p>@property = getter + setter;</p>
</blockquote>
<p>例如下面这个类：</p>
<pre><code><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject 
<span class="variable">@property</span> NSString *firstName; 
<span class="variable">@property</span> NSString *lastName; 
<span class="variable">@end</span> 
</code></pre><p>上述代码写出来的类与下面这种写法等效：</p>
<pre><code>@interface <span class="keyword">Person</span> : NSObject 
- (NSString *)firstName; 
- (void)setFirstName:(NSString *)firstName; 
- (NSString *)lastName; 
- (void)setLastName:(NSString *)lastName; 
@end 
</code></pre><p><strong>ivar、getter、setter 是如何生成并添加到这个类中的?</strong></p>
<blockquote>
<p>“自动合成”( autosynthesis)</p>
</blockquote>
<p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”( autosynthesis)。需要强调的是，这个过程由编译<br>器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为<br><code>_firstName</code>与<code>_lastName</code>。也可以在类的实现代码里通过<br>@synthesize语法来指定实例变量的名字.</p>
<pre><code><span class="variable">@implementation</span> Person 
<span class="variable">@synthesize</span> firstName = _myFirstName; 
<span class="variable">@synthesize</span> lastName = _myLastName; 
<span class="variable">@end</span> 
</code></pre><p>我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西</p>
<ol>
<li><code>OBJC_IVAR_$类名$属性名称</code> ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。</li>
<li>setter与getter方法对应的实现函数</li>
<li><code>ivar_list</code> ：成员变量列表</li>
<li><code>method_list</code> ：方法列表</li>
<li><code>prop_list</code> ：属性列表</li>
</ol>
<p>也就是说我们每次在增加一个属性,系统都会在<code>ivar_list</code>中添加一个成员变量的描述,在<code>method_list</code>中增加setter与getter方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出setter与getter方法对应的实现,在setter方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.</p>
<p>###7. @protocol 和 category 中如何使用 @property</p>
<ol>
<li>在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</li>
<li><p>category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数：</p>
<ol>
<li><code>objc_setAssociatedObject</code></li>
<li><code>objc_getAssociatedObject</code></li>
</ol>
</li>
</ol>
<p>###8. runtime 如何实现 weak 属性</p>
<p>要实现weak属性，首先要搞清楚weak属性的特点：</p>
<blockquote>
<p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>
</blockquote>
<p>那么runtime如何实现weak变量的自动置nil？</p>
<blockquote>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
</blockquote>
<p>（注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到<code>__weak</code>引用的解除时间。）</p>
<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>
<p><code>objc_storeWeak(&amp;a, b)</code>函数：</p>
<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，</p>
<p>你可以把<code>objc_storeWeak(&amp;a, b)</code>理解为：<code>objc_storeWeak(value, key)</code>，并且当key变nil，将value置nil。</p>
<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>
<p>而如果a是由assign修饰的，则：<br>在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>
<p>下面我们将基于<code>objc_storeWeak(&amp;a, b)</code>函数，使用伪代码模拟“runtime如何实现weak属性”：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20351;&#29992;&#20266;&#20195;&#30721;&#27169;&#25311;&#65306;runtime&#22914;&#20309;&#23454;&#29616;weak&#23646;&#24615;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;&#10; id obj1;&#10; objc_initWeak(&#38;obj1, obj);&#10;/*obj&#24341;&#29992;&#35745;&#25968;&#21464;&#20026;0&#65292;&#21464;&#37327;&#20316;&#29992;&#22495;&#32467;&#26463;*/&#10; objc_destroyWeak(&#38;obj1);</span><br></pre></td></tr></table></figure>
<p>下面对用到的两个方法<code>objc_initWeak</code>和<code>objc_destroyWeak</code>做下解释：</p>
<p>总体说来，作用是：<br>通过<code>objc_initWeak</code>函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过<code>objc_destoryWeak</code>函数释放该变量（obj1）。</p>
<p>下面分别介绍下方法的内部实现：</p>
<p><code>objc_initWeak</code>函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用<code>objc_storeWeak</code>函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj1 = 0&#65307;&#10;obj_storeWeak(&#38;obj1, obj);</span><br></pre></td></tr></table></figure>
<p>也就是说：</p>
<blockquote>
<p> weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>
</blockquote>
<p>然后<code>obj_destroyWeak</code>函数将0（nil）作为参数，调用<code>objc_storeWeak</code>函数。</p>
<p><code>objc_storeWeak(&amp;obj1, 0);</code></p>
<p>前面的源代码与下列源代码相同。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20351;&#29992;&#20266;&#20195;&#30721;&#27169;&#25311;&#65306;runtime&#22914;&#20309;&#23454;&#29616;weak&#23646;&#24615;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;&#10;id obj1;&#10;obj1 = 0;&#10;objc_storeWeak(&#38;obj1, obj);&#10;/* ... obj&#30340;&#24341;&#29992;&#35745;&#25968;&#21464;&#20026;0&#65292;&#34987;&#32622;nil ... */&#10;objc_storeWeak(&#38;obj1, 0);</span><br></pre></td></tr></table></figure>
<p><code>objc_storeWeak</code>函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。</p>
<p>使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：</p>
<blockquote>
<p>如何让不使用weak修饰的@property，拥有weak的效果。</p>
</blockquote>
<p>我们从setter方法入手：</p>
<pre><code>- (void)setObject:(<span class="type">NSObject</span> *)<span class="class"><span class="keyword">object</span>
</span>{
    objc_setAssociatedObject(self, <span class="string">"object"</span>, <span class="class"><span class="keyword">object</span>, <span class="title">OBJC_ASSOCIATION_ASSIGN</span>);</span>
    [<span class="class"><span class="keyword">object</span> <span class="title">cyl_runAtDealloc</span>:</span>^{
        _object = nil;
    }];
}
</code></pre><p>也就是有两个步骤：</p>
<ol>
<li><p>在setter方法中做如下设置：</p>
<pre><code>objc_setAssociatedObject<span class="list">(<span class="keyword">self</span>, <span class="string">"object"</span>, object, OBJC_ASSOCIATION_ASSIGN)</span><span class="comment">;</span>
</code></pre></li>
<li><p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助runtime：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#35201;&#38144;&#27585;&#30340;&#30446;&#26631;&#23545;&#35937;&#10;id objectToBeDeallocated;&#10;//&#21487;&#20197;&#29702;&#35299;&#20026;&#19968;&#20010;&#8220;&#20107;&#20214;&#8221;&#65306;&#24403;&#19978;&#38754;&#30340;&#30446;&#26631;&#23545;&#35937;&#38144;&#27585;&#26102;&#65292;&#21516;&#26102;&#35201;&#21457;&#29983;&#30340;&#8220;&#20107;&#20214;&#8221;&#12290;&#10;id objectWeWantToBeReleasedWhenThatHappens;&#10;objc_setAssociatedObject(objectToBeDeallocted,&#10;                         someUniqueKey,&#10;                         objectWeWantToBeReleasedWhenThatHappens,&#10;                         OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>知道了思路，我们就开始实现<code>cyl_runAtDealloc</code>方法，实现过程分两部分：</p>
<p>第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</p>
<pre><code><span class="comment">// .h文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</span>

<span class="keyword">typedef</span> <span class="keyword">void</span> (^voidBlock)(<span class="keyword">void</span>);

<span class="class"><span class="keyword">@interface</span> <span class="title">CYLBlockExecutor</span> : <span class="title">NSObject</span> </span>

- (<span class="keyword">id</span>)initWithBlock:(voidBlock)block;

<span class="keyword">@end</span>


<span class="comment">// .m文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。</span>

<span class="preprocessor">#import <span class="title">"CYLBlockExecutor.h"</span></span>

<span class="class"><span class="keyword">@interface</span> <span class="title">CYLBlockExecutor</span>() </span>{
    voidBlock _block;
}
<span class="class"><span class="keyword">@implementation</span> <span class="title">CYLBlockExecutor</span></span>

- (<span class="keyword">id</span>)initWithBlock:(voidBlock)aBlock
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];

    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        _block = [aBlock <span class="keyword">copy</span>];
    }

    <span class="keyword">return</span> <span class="keyword">self</span>;
}

- (<span class="keyword">void</span>)dealloc
{
    _block ? _block() : <span class="literal">nil</span>;
}

<span class="keyword">@end</span>
</code></pre><p>第二部分：核心代码：利用runtime实现<code>cyl_runAtDealloc</code>方法</p>
<pre><code><span class="comment">// CYLNSObject+RunAtDealloc.h文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 利用runtime实现cyl_runAtDealloc方法</span>

<span class="preprocessor">#import <span class="title">"CYLBlockExecutor.h"</span></span>

<span class="keyword">const</span> <span class="keyword">void</span> *runAtDeallocBlockKey = &amp;runAtDeallocBlockKey;

<span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">CYLRunAtDealloc</span>)</span>

- (<span class="keyword">void</span>)cyl_runAtDealloc:(voidBlock)block;

<span class="keyword">@end</span>


<span class="comment">// CYLNSObject+RunAtDealloc.m文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 利用runtime实现cyl_runAtDealloc方法</span>

<span class="preprocessor">#import <span class="title">"CYLNSObject+RunAtDealloc.h"</span></span>
<span class="preprocessor">#import <span class="title">"CYLBlockExecutor.h"</span></span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">CYLRunAtDealloc</span>)</span>

- (<span class="keyword">void</span>)cyl_runAtDealloc:(voidBlock)block
{
    <span class="keyword">if</span> (block) {
        CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];

        objc_setAssociatedObject(<span class="keyword">self</span>,
                                 runAtDeallocBlockKey,
                                 executor,
                                 OBJC_ASSO<span class="built_in">CIATION_RETAIN</span>);
    }
}

<span class="keyword">@end</span>
</code></pre><p>使用方法：<br>导入</p>
<pre><code><span class="id">#import</span> <span class="string">"CYLNSObject+RunAtDealloc.h"</span>
</code></pre><p>然后就可以使用了：</p>
<pre><code><span class="built_in">NSObject</span> *foo = [[<span class="built_in">NSObject</span> alloc] init];

[foo cyl_runAtDealloc:^{
    <span class="built_in">NSLog</span>(<span class="string">@"正在释放foo!"</span>);
}];
</code></pre><p>如果对<code>cyl_runAtDealloc</code>的实现原理有兴趣，可以看下这篇博文 <a href="http://stackoverflow.com/a/31560217/3395008" target="_blank" rel="external"><strong><em>Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object</em></strong></a></p>
<p>###9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？<br>属性可以拥有的特质分为四类:</p>
<ol>
<li><p>原子性—<code>nonatomic</code>特质</p>
<p>在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备nonatomic特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。</p>
</li>
<li><p>读/写权限—<code>readwrite(读写)</code>、<code>readooly (只读)</code></p>
</li>
<li>内存管理语义—<code>assign</code>、<code>strong</code>、 <code>weak</code>、<code>unsafe_unretained</code>、<code>copy</code></li>
<li><p>方法名—<code>getter=&lt;name&gt;</code> 、<code>setter=&lt;name&gt;</code></p>
<p><code>getter=&lt;name&gt;</code>的样式：</p>
<pre><code>@<span class="keyword">property</span> (nonatomic, getter=isOn) BOOL <span class="function_start"><span class="keyword">on</span></span>;
</code></pre><p>（ <code>setter=&lt;name&gt;</code>这种不常用，也不推荐使用。故不在这里给出写法。）</p>
</li>
<li>不常用的：<code>nonnull</code>,<code>null_resettable</code>,<code>nullable</code></li>
</ol>
<p>###10. weak属性需要在dealloc中置nil么？<br>不需要。</p>
<blockquote>
<p>在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</p>
</blockquote>
<p>即便是编译器不帮我们做这些，weak也不需要在dealloc中置nil：</p>
<p>正如上文的：<strong><em>runtime 如何实现 weak 属性</em></strong> 中提到的：</p>
<p>我们模拟下weak的setter方法，应该如下：</p>
<pre><code>- (void)setObject:(<span class="type">NSObject</span> *)<span class="class"><span class="keyword">object</span>
</span>{
    objc_setAssociatedObject(self, <span class="string">"object"</span>, <span class="class"><span class="keyword">object</span>, <span class="title">OBJC_ASSOCIATION_ASSIGN</span>);</span>
    [<span class="class"><span class="keyword">object</span> <span class="title">cyl_runAtDealloc</span>:</span>^{
        _object = nil;
    }];
}
</code></pre><p>也即:</p>
<blockquote>
<p>在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>
</blockquote>
<p>###11. @synthesize和@dynamic分别有什么作用？</p>
<ol>
<li>@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是<code>@syntheszie var = _var;</code></li>
<li>@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic告诉编译器：属性的setter与getter方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到<code>instance.var = someVar</code>，由于缺setter方法会导致程序崩溃；或者当运行到 <code>someVar = var</code>时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ol>
<p>###12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</p>
<ol>
<li><p>对应基本数据类型默认关键字是</p>
<p>atomic,readwrite,assign</p>
</li>
<li><p>对于普通的OC对象</p>
<p>atomic,readwrite,strong</p>
</li>
</ol>
<p>参考链接：</p>
<ol>
<li><p><a href="http://stackoverflow.com/a/15541801/3395008" target="_blank" rel="external"> <strong><em>Objective-C ARC: strong vs retain and weak vs assign</em></strong> </a></p>
</li>
<li><p><a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html" target="_blank" rel="external"> <strong><em>Variable property attributes or Modifiers in iOS</em></strong> </a></p>
</li>
</ol>
<p>###13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</p>
<ol>
<li>因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li>如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</li>
</ol>
<p>copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。<br>当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
<p>为了理解这种做法，首先要知道，对非集合类对象的copy操作：</p>
<p>在非集合类对象中：对immutable对象进行copy操作，是指针复制，mutableCopy操作时内容复制；对mutable对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：</p>
<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>
<p>比如以下代码：</p>
<pre><code><span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"origin"</span>];<span class="comment">//copy</span>
<span class="built_in">NSString</span> *stringCopy = [string <span class="keyword">copy</span>]; 
</code></pre><p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>
<pre><code>[string appendString:@<span class="string">"origion!"</span>]
</code></pre><p>stringCopy的值也不会因此改变，但是如果不使用copy，stringCopy的值就会被改变。<br>  集合类对象以此类推。<br>所以，</p>
<blockquote>
<p>用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
</blockquote>
<p>参考链接：<a href="https://www.zybuluo.com/MicroCai/note/50592" target="_blank" rel="external">iOS 集合的深复制与浅复制</a></p>
<p>###14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为<code>_foo</code>的实例变量，那么还会自动合成新变量么？<br>在回答之前先说明下一个概念：</p>
<blockquote>
<p>实例变量 = 成员变量 ＝ ivar</p>
</blockquote>
<p>这些说法，笔者下文中，可能都会用到，指的是一个东西。</p>
<p>正如<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6" target="_blank" rel="external">Apple官方文档 <strong><em>You Can Customize Synthesized Instance Variable Names</em></strong></a> 所说：<br><img src="http://i.imgur.com/D6d0zGJ.png" alt="enter image description here"></p>
<p>如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface CYLPerson : NSObject &#10;@property NSString *firstName; &#10;@property NSString *lastName; &#10;@end</span><br></pre></td></tr></table></figure>
<p>在上例中，会生成两个实例变量，其名称分别为<br><code>_firstName</code>与<code>_lastName</code>。也可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation CYLPerson &#10;@synthesize firstName = _myFirstName; &#10;@synthesize lastName = _myLastName; &#10;@end</span><br></pre></td></tr></table></figure>
<p>上述语法会将生成的实例变量命名为<code>_myFirstName</code>与<code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>
<p>总结下@synthesize合成实例变量的规则，有以下几点：</p>
<ol>
<li><p>如果指定了成员变量的名称,会生成一个指定的名称的成员变量,</p>
</li>
<li><p>如果这个成员已经存在了就不再生成了.</p>
</li>
<li><p>如果是 <code>@synthesize foo;</code> 还会生成一个名称为foo的成员变量，也就是说：</p>
<blockquote>
<p>如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,</p>
</blockquote>
</li>
</ol>
<ol>
<li>如果是 <code>@synthesize foo = _foo;</code> 就不会生成成员变量了.</li>
</ol>
<p>假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？<br>不会。如下图：</p>
<p><img src="http://i.imgur.com/t28ge4W.png" alt="enter image description here"></p>
<p>###15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</p>
<p>回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？</p>
<ol>
<li>同时重写了setter和getter时</li>
<li>重写了只读属性的getter时</li>
<li>使用了@dynamic时</li>
<li>在 @protocol 中定义的所有属性</li>
<li>在 category 中定义的所有属性</li>
<li><p>重载的属性 </p>
<p>当你在子类中重载了父类中的属性，你必须 使用<code>@synthesize</code>来手动合成ivar。</p>
</li>
</ol>
<p>除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理@property的所有内容时，你就会尝试通过实现@property的所有“存取方法”（the accessor methods）或者使用<code>@dynamic</code>来达到这个目的，这时编译器就会认为你打算手动管理@property，于是编译器就禁用了autosynthesis（自动合成）。</p>
<p>因为有了autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于autosynthesis（自动合成），但是一旦你需要使用ivar，而autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助<code>@synthesize</code>来手动合成ivar。</p>
<p>其实，<code>@synthesize</code>语法还有一个应用场景，但是不太建议大家使用：</p>
<p>可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@implementation CYLPerson &#10;@synthesize firstName = _myFirstName; &#10;@synthesize lastName = _myLastName; &#10;@end</span><br></pre></td></tr></table></figure>
<p>上述语法会将生成的实例变量命名为<code>_myFirstName</code>与<code>_myLastName</code>，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。</p>
<p>举例说明：应用场景：</p>
<pre><code><span class="comment">//</span>
<span class="comment">// .m文件</span>
<span class="comment">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 打开第14行和第17行中任意一行，就可编译成功</span>

@import Foundation;

<span class="class"><span class="keyword">@interface</span> <span class="title">CYLObject</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">CYLObject</span> </span>{
<span class="comment">//    NSString *_title;</span>
}

<span class="comment">//@synthesize title = _title;</span>

- (instancetype)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        _title = <span class="string">@"微博@iOS程序犭袁"</span>;
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}

- (<span class="built_in">NSString</span> *)title {
    <span class="keyword">return</span> _title;
}

- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title {
    _title = [title <span class="keyword">copy</span>];
}

<span class="keyword">@end</span>
</code></pre><p>结果编译器报错：<br><img src="http://i.imgur.com/fAEGHIo.png" alt="enter image description here"></p>
<p>当你同时重写了setter和getter时，系统就不会生成ivar（实例变量/成员变量）。这时候有两种选择：</p>
<ol>
<li>要么如第14行：手动创建ivar</li>
<li>要么如第17行：使用<code>@synthesize foo = _foo;</code> ，关联@property与ivar。</li>
</ol>
<p>更多信息，请戳- 》<a href="http://stackoverflow.com/a/19821816/3395008" target="_blank" rel="external"> <strong><em>When should I use @synthesize explicitly?</em></strong> </a></p>
<p>###16. objc中向一个nil对象发送消息将会发生什么？<br>在Objective-C中向nil发送消息是完全有效的——只是在运行时不会有任何作用:</p>
<ol>
<li>如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：  </li>
</ol>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person * motherInlaw = [[aPerson spouse] mother];</span><br></pre></td></tr></table></figure>
<p> 如果spouse对象为nil，那么发送给nil的消息mother也将返回nil。</p>
<ol>
<li>如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。</li>
<li>如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0。</li>
<li>如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。</li>
</ol>
<p>具体原因如下：</p>
<blockquote>
<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</blockquote>
<p>那么，为了方便理解这个内容，还是贴一个objc的源代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;// runtime.h&#65288;&#31867;&#22312;runtime&#20013;&#30340;&#23450;&#20041;&#65289;&#10;// http://weibo.com/luohanchenyilong/&#10;// https://github.com/ChenYilong&#10;&#10;struct objc_class &#123;&#10;  Class isa OBJC_ISA_AVAILABILITY; //isa&#25351;&#38024;&#25351;&#21521;Meta Class&#65292;&#22240;&#20026;Objc&#30340;&#31867;&#30340;&#26412;&#36523;&#20063;&#26159;&#19968;&#20010;Object&#65292;&#20026;&#20102;&#22788;&#29702;&#36825;&#20010;&#20851;&#31995;&#65292;runtime&#23601;&#21019;&#36896;&#20102;Meta Class&#65292;&#24403;&#32473;&#31867;&#21457;&#36865;[NSObject alloc]&#36825;&#26679;&#28040;&#24687;&#26102;&#65292;&#23454;&#38469;&#19978;&#26159;&#25226;&#36825;&#20010;&#28040;&#24687;&#21457;&#32473;&#20102;Class Object&#10;  #if !__OBJC2__&#10;  Class super_class OBJC2_UNAVAILABLE; // &#29238;&#31867;&#10;  const char *name OBJC2_UNAVAILABLE; // &#31867;&#21517;&#10;  long version OBJC2_UNAVAILABLE; // &#31867;&#30340;&#29256;&#26412;&#20449;&#24687;&#65292;&#40664;&#35748;&#20026;0&#10;  long info OBJC2_UNAVAILABLE; // &#31867;&#20449;&#24687;&#65292;&#20379;&#36816;&#34892;&#26399;&#20351;&#29992;&#30340;&#19968;&#20123;&#20301;&#26631;&#35782;&#10;  long instance_size OBJC2_UNAVAILABLE; // &#35813;&#31867;&#30340;&#23454;&#20363;&#21464;&#37327;&#22823;&#23567;&#10;  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // &#35813;&#31867;&#30340;&#25104;&#21592;&#21464;&#37327;&#38142;&#34920;&#10;  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // &#26041;&#27861;&#23450;&#20041;&#30340;&#38142;&#34920;&#10;  struct objc_cache *cache OBJC2_UNAVAILABLE; // &#26041;&#27861;&#32531;&#23384;&#65292;&#23545;&#35937;&#25509;&#21040;&#19968;&#20010;&#28040;&#24687;&#20250;&#26681;&#25454;isa&#25351;&#38024;&#26597;&#25214;&#28040;&#24687;&#23545;&#35937;&#65292;&#36825;&#26102;&#20250;&#22312;method Lists&#20013;&#36941;&#21382;&#65292;&#22914;&#26524;cache&#20102;&#65292;&#24120;&#29992;&#30340;&#26041;&#27861;&#35843;&#29992;&#26102;&#23601;&#33021;&#22815;&#25552;&#39640;&#35843;&#29992;&#30340;&#25928;&#29575;&#12290;&#10;  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // &#21327;&#35758;&#38142;&#34920;&#10;  #endif&#10;  &#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。<br>那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>
<p>###17. objc中向一个对象发送消息[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系？<br>具体原因同上题：该方法编译之后就是<code>objc_msgSend()</code>函数调用.</p>
<p>我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和<code>objc_msgSend()</code>函数之间有什么关系。</p>
<p>以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#10;//  main.m&#10;//  http://weibo.com/luohanchenyilong/&#10;//  https://github.com/ChenYilong&#10;//  Copyright (c) 2015&#24180; &#24494;&#21338;@iOS&#31243;&#24207;&#29357;&#34945;. All rights reserved.&#10;//&#10;&#10;&#10;#import &#34;CYLTest.h&#34;&#10;&#10;int main(int argc, char * argv[]) &#123;&#10;    @autoreleasepool &#123;&#10;        CYLTest *test = [[CYLTest alloc] init];&#10;        [test performSelector:(@selector(iOSinit))];&#10;        return 0;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在终端中输入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
<p>就可以生成一个<code>main.cpp</code>的文件，在最低端（10万4千行左右）</p>
<p><img src="http://i.imgur.com/eAH5YWn.png" alt="enter image description here"></p>
<p>我们可以看到大概是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(&#34;foo&#34;));</span><br></pre></td></tr></table></figure>
<p>也就是说：</p>
<blockquote>
<p> [obj foo];在objc动态编译时，会被转意为：<code>objc_msgSend(obj, @selector(foo));</code>。</p>
</blockquote>
<p>###18. 什么时候会报unrecognized selector的异常？</p>
<p>简单来说：</p>
<blockquote>
<p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候，<br>可以通过“消息转发”进行解决。</p>
</blockquote>
<p>简单的流程如下，在上一题中也提到过：</p>
<blockquote>
<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</blockquote>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p>
<ol>
<li><p>Method resolution</p>
<p>objc运行时会调用<code>+resolveInstanceMethod:</code>或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回 YES，那运行时系统就会重新启动一次消息发送的过程，如果 resolve 方法返回 NO ，运行时就会移到下一步，消息转发（Message Forwarding）。</p>
</li>
<li><p>Fast forwarding</p>
<p>如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。<br>只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。<br>这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p>
</li>
<li><p>Normal forwarding</p>
<p>这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回nil，Runtime则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p>
</li>
</ol>
<p>###19. 一个objc对象如何进行内存布局？（考虑有父类的情况）</p>
<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的</li>
</ul>
<ol>
<li>对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）</li>
<li>成员变量的列表,</li>
<li><p>属性列表,</p>
<p>它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</p>
</li>
</ol>
<p>每个 Objective-C 对象都有相同的结构，如下图所示：</p>
<p> <img src="http://i.imgur.com/7mJlUj1.png" alt="enter image description here"></p>
<p>翻译过来就是</p>
<table>
<thead>
<tr>
<th></th>
<th>Objective-C 对象的结构图</th>
</tr>
</thead>
<tbody>
<tr>
<td> ISA指针</td>
<td></td>
</tr>
<tr>
<td> 根类的实例变量</td>
<td></td>
</tr>
<tr>
<td> 倒数第二层父类的实例变量</td>
<td></td>
</tr>
<tr>
<td> …</td>
<td></td>
</tr>
<tr>
<td> 父类的实例变量</td>
<td></td>
</tr>
<tr>
<td> 类的实例变量</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><p>根对象就是NSobject，它的superclass指针指向nil</p>
</li>
<li><p>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</p>
</li>
</ul>
<p>如图:<br><img src="http://i.imgur.com/w6tzFxz.png" alt="enter image description here"></p>
<p>###20. 一个objc对象的isa的指针指向什么？有什么作用？</p>
<p>指向他的类对象,从而可以找到对象上的方法</p>
<p>###21. 下面的代码输出什么？</p>
<pre><code><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span>
- (<span class="keyword">id</span>)init
{
    <span class="keyword">self</span> = [<span class="keyword">super</span> init];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {
        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));
        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> class]));
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="keyword">@end</span>
</code></pre><p><strong>答案：</strong></p>
<p>都输出 Son</p>
<pre><code>NSStringFromClass([<span class="variable">self</span> <span class="class"><span class="keyword">class</span>]) = <span class="title">Son</span></span>
NSStringFromClass([<span class="variable">super</span> <span class="class"><span class="keyword">class</span>]) = <span class="title">Son</span></span>
</code></pre><p><strong>解惑：</strong></p>
<p>（以下解惑部分摘自<a href="http://weibo.com/junbbcom" target="_blank" rel="external">微博@Chun_iOS</a>的博文<a href="http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1" target="_blank" rel="external">刨根问底Objective－C Runtime（1）－ Self &amp; Super</a>%5Bnil%5D-self-and-super/)）</p>
<p>这个题目主要是考察关于objc中对 self 和 super 的理解。</p>
<p>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。</p>
<p>上面的例子不管调用<code>[self class]</code>还是<code>[super class]</code>，接受消息的对象都是当前 <code>Son ＊xxx</code> 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>
<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>
<p>真的是这样吗？继续看：</p>
<p>使用clang重写命令:</p>
<pre><code>$ clang -rewrite-objc <span class="keyword">test</span>.<span class="literal">m</span>
</code></pre><p>发现上述代码被转化为:</p>
<pre><code>NSLog<span class="params">(<span class="params">(NSString *)</span>&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass<span class="params">(<span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>self, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>)</span>)</span>;

NSLog<span class="params">(<span class="params">(NSString *)</span>&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass<span class="params">(<span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(__rw_objc_super *, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSendSuper)</span><span class="params">(<span class="params">(__rw_objc_super)</span>{ <span class="params">(id)</span>self, <span class="params">(id)</span>class_getSuperclass<span class="params">(objc_getClass<span class="params">(<span class="string">"Son"</span>)</span>)</span> }, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>)</span>)</span>;
</code></pre><p>从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>
<pre><code><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)
</code></pre><p>我们把 self 做为第一个参数传递进去。</p>
<p>而在调用 [super class]时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>
<pre><code><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)
</code></pre><p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>{
   __unsafe_unretained id receiver;
   __unsafe_unretained Class super_class;
};
</code></pre><p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 <code>objc_msgSend</code>函数第一个参数self 。第二个成员是记录当前类的父类是什么。</p>
<p>所以，当调用 ［self class] 时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。</p>
<p>objc Runtime开源代码对- (Class)class方法的实现:</p>
<pre><code>- (<span class="constant">Class</span>)<span class="class"><span class="keyword">class</span> {</span>
    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);
}
</code></pre><p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper函数</code>。第一步先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。<br>第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code> , 实际该函数输出结果为 Father。<br>第二步是去 Father这个类里去找 <code>- (Class)class</code>，没有，然后去NSObject类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，<br>此时已经和<code>[self class]</code>调用相同了，故上述输出结果仍然返回 Son。</p>
<p>###22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</p>
<p>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>
<p>###23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</p>
<ul>
<li>在ARC下不需要。</li>
<li><p><del> 在MRC中,对于使用retain或copy策略的需要 。</del></p>在MRC下也不需要</li>
</ul>
<blockquote>
<p>无论在MRC下还是ARC下均不需要。</p>
</blockquote>
<p><a href="https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html" target="_blank" rel="external"> <strong><em>2011年版本的Apple API 官方文档 - Associative References</em></strong>  </a> 一节中有一个MRC环境下的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22312;MRC&#19979;&#65292;&#20351;&#29992;runtime Associate&#26041;&#27861;&#20851;&#32852;&#30340;&#23545;&#35937;&#65292;&#19981;&#38656;&#35201;&#22312;&#20027;&#23545;&#35937;dealloc&#30340;&#26102;&#20505;&#37322;&#25918;&#10;// http://weibo.com/luohanchenyilong/ (&#24494;&#21338;@iOS&#31243;&#24207;&#29357;&#34945;)&#10;// https://github.com/ChenYilong&#10;// &#25688;&#33258;2011&#24180;&#29256;&#26412;&#30340;Apple API &#23448;&#26041;&#25991;&#26723; - Associative References &#10;&#10;static char overviewKey;&#10; &#10;NSArray *array =&#10;    [[NSArray alloc] initWithObjects:@&#34;One&#34;, @&#34;Two&#34;, @&#34;Three&#34;, nil];&#10;// For the purposes of illustration, use initWithFormat: to ensure&#10;// the string can be deallocated&#10;NSString *overview =&#10;    [[NSString alloc] initWithFormat:@&#34;%@&#34;, @&#34;First three numbers&#34;];&#10; &#10;objc_setAssociatedObject (&#10;    array,&#10;    &#38;overviewKey,&#10;    overview,&#10;    OBJC_ASSOCIATION_RETAIN&#10;);&#10; &#10;[overview release];&#10;// (1) overview valid&#10;[array release];&#10;// (2) overview invalid</span><br></pre></td></tr></table></figure>
<p>文档指出 </p>
<blockquote>
<p>At point 1, the string <code>overview</code> is still valid because the <code>OBJC_ASSOCIATION_RETAIN</code> policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), <code>overview</code> is released and so in this case also deallocated.</p>
</blockquote>
<p>我们可以看到，在<code>[array release];</code>之后，overview就会被release释放掉了。</p>
<p>既然会被销毁，那么具体在什么时间点？</p>
<blockquote>
<p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video" target="_blank" rel="external"> <strong><em>WWDC 2011, Session 322 (第36分22秒)</em></strong> </a>中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</p>
</blockquote>
<p>对象的内存销毁时间表，分四个步骤：</p>
<pre><code><span class="comment">// 对象的内存销毁时间表</span>
<span class="comment">// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)</span>
<span class="comment">// https://github.com/ChenYilong</span>
<span class="comment">// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 </span>

 1. 调用 -release ：引用计数变为零
<span class="comment">     * 对象正在被销毁，生命周期即将结束.</span>
<span class="comment">     * 不能再有新的 __weak 弱引用， 否则将指向 nil.</span>
<span class="comment">     * 调用 [self dealloc] </span>
 2. 父类 调用 -dealloc
<span class="comment">     * 继承关系中最底层的父类 在调用 -dealloc</span>
<span class="comment">     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）</span>
<span class="comment">     * 继承关系中每一层的父类 都在调用 -dealloc</span>
 3. NSObject 调 -dealloc
<span class="comment">     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法</span>
 4. 调用 object_dispose()
<span class="comment">     * 为 C++ 的实例变量们（iVars）调用 destructors </span>
<span class="comment">     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release </span>
<span class="comment">     * 解除所有使用 runtime Associate方法关联的对象</span>
<span class="comment">     * 解除所有 __weak 引用</span>
<span class="comment">     * 调用 free()</span>
</code></pre><p>对象的内存销毁时间表：<a href="http://stackoverflow.com/a/10843510/3395008" target="_blank" rel="external">参考链接</a>。</p>
<p>###24. objc中的类方法和实例方法有什么本质区别和联系？</p>
<p>类方法：</p>
<ol>
<li>类方法是属于类对象的</li>
<li>类方法只能通过类对象调用</li>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li>类方法中不能访问成员变量</li>
<li>类方法中不定直接调用对象方法</li>
</ol>
<p>实例方法：</p>
<ol>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ol>
<h2 id="下一篇文章将发布在这里，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注微博@iOS程序犭袁">下一篇文章将发布在<a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="external">这里</a>，会对以下问题进行总结，并将本篇文章的勘误一并列出，欢迎指正！请持续关注<a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a></h2><p>@property部分主要参考<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2" target="_blank" rel="external">Apple官方文档：Properties Encapsulate an Object’s Values</a><br>runtime部分主要参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="external">Apple官方文档：Declared Properties</a></p>
<p>###25. <code>_objc_msgForward</code>函数是做什么的，直接调用它将会发生什么？</p>
<p>###26. runtime如何实现weak变量的自动置nil？</p>
<p>###27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ </p>
<p>###28. runloop和线程有什么关系？</p>
<p>###29. runloop的mode作用是什么？</p>
<p>###30. 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</p>
<p>###31. 猜想runloop内部是如何实现的？</p>
<p>###32. objc使用什么机制管理对象内存？</p>
<p>###33. ARC通过什么方式帮助开发者管理内存？</p>
<p>###34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）</p>
<p>###35. <code>BAD_ACCESS</code>在什么情况下出现？</p>
<p>###36. 苹果是如何实现autoreleasepool的？ </p>
<p>###37. 使用block时什么情况会发生引用循环，如何解决？</p>
<p>###38. 在block内如何修改block外部变量？</p>
<p>###39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ </p>
<p>###40. GCD的队列（<code>dispatch_queue_t</code>）分哪两种类型？</p>
<p>###41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</p>
<p>###42. <code>dispatch_barrier_async</code>的作用是什么？</p>
<p>###43. 苹果为什么要废弃<code>dispatch_get_current_queue</code>？</p>
<p>###44. 以下代码运行结果如何？</p>
<pre><code>- (void)viewDidLoad
{
    <span class="attr_selector">[super viewDidLoad]</span>;
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"1"</span>);</span>
    <span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
        <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"2"</span>);</span>
    });
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"3"</span>);</span>
}
</code></pre><p>###45. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</p>
<p>###46. 如何手动触发一个value的KVO</p>
<p>###47. 若一个类有实例变量<code>NSString *_foo</code>，调用setValue:forKey:时，可以以foo还是<code>_foo</code>作为key？</p>
<p>###48. KVC的keyPath中的集合运算符如何使用？</p>
<p>###49. KVC和KVO的keyPath一定是属性么？</p>
<p>###50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</p>
<p>###51. apple用什么方式实现对一个对象的KVO？ </p>
<p>###52. IBOutlet连出来的视图属性为什么可以被设置成weak?</p>
<p>###53. IB中User Defined Runtime Attributes如何使用？ </p>
<p>###54. 如何调试<code>BAD_ACCESS</code>错误</p>
<p>###55. lldb（gdb）常用的调试命令？</p>
<hr>
<p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="external">Creative Commons BY-NC-ND 3.0</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/02/iOS面试题和参考答案（上篇）/" data-id="ciedk5cs000053pi0rohy2vla" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-随笔小记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/01/随笔小记/" class="article-date">
  <time datetime="2015-09-01T00:44:05.000Z" itemprop="datePublished">2015-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/01/随笔小记/">随笔小记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="理论知识">理论知识</h1><p>//遇见的问题</p>
<h2 id="(1)新建继承于NSObject的类时，调不出CGRect等属性">(1)新建继承于NSObject的类时，调不出CGRect等属性</h2><p>解决 ：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">添加<span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="(2)NSstring_*str_=_[NSdata_alloc]_init];">(2)NSstring *str = [NSdata alloc] init];</h2><p>如何理解这句话</p>
<p>首先声明NSstring *str这句话是告诉编译器 str是指向一个OC对象的指针，不管指向的是什么类型的对象，一个指针所对应的内存空间是固定的，所以这里声明成任何类型的对象，最终生成的可执行的代码是没有区别的。这里限定NSstring只是告诉编译器把str当做一个NSString类型来检查，如果后边调用了费NSString方法，编译器会发出警告。</p>
<p>等号右边创建了一个NSdata对象，这个对象的内存地址保存在str处，在运行时str指向的内存空间就是一个NSdata对象，这样可以吧str当成一个NSdata对象来使用。</p>
<h2 id="(3)iOS_7-0之后的lable自适应高度">(3)iOS 7.0之后的lable自适应高度</h2><p>直接上代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UILabel</span> *sizelable = [[<span class="built_in">UILabel</span> alloc] init];</span><br><span class="line">    sizelable<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line">    sizelable<span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">    sizelable<span class="variable">.text</span> = <span class="string">@"第三款看懂啊ok豆粕你电脑没打案发破产破奥剑南春脑残片破富婆佛爬满覅实地偶发IOS吗覅破发颇丰平假的加盟哦没法买欧普发票，破发妈妈破偶发佛怕哦平方毛坯莫怕磨破"</span>;</span><br><span class="line">    sizelable<span class="variable">.numberOfLines</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">CGRect</span> rect  = [sizelable<span class="variable">.text</span> boundingRectWithSize:<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="built_in">CGFLOAT_MAX</span>) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> |<span class="built_in">NSStringDrawingUsesFontLeading</span> attributes:[<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>],<span class="built_in">NSFontAttributeName</span>, <span class="literal">nil</span>] context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line"> sizelable<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, rect<span class="variable">.size</span><span class="variable">.height</span>+<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>注意点：（1）numberOfLines属性设为0。<br>       （2）字典中的字体要保持一致<br>        （3）换行格式要两种格式都要写上，不然有可能计算不准确</p>
<h2 id="根据根据给定的字符串计算lable的宽度">根据根据给定的字符串计算lable的宽度</h2><p>（多少号的字体，这个字所占的宽度就是多少）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"aaa"</span>;</span><br><span class="line">    <span class="built_in">UILabel</span> *lable = [[<span class="built_in">UILabel</span> alloc] init];</span><br><span class="line">    lable<span class="variable">.text</span> = str;</span><br><span class="line">    lable<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    lable<span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">    </span><br><span class="line"> <span class="built_in">CGSize</span> lableize = [lable<span class="variable">.text</span> sizeWithAttributes:[<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>],<span class="built_in">NSFontAttributeName</span>, <span class="literal">nil</span>]];</span><br><span class="line">    lable<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, lableize<span class="variable">.width</span>, lableize<span class="variable">.height</span>);</span><br></pre></td></tr></table></figure>
<h1 id="（1）-使用视图控制器（View_Controller）">（1）.使用视图控制器（View Controller）</h1><p>在iOS 7中，视图控制器都是全屏的。iOS 7视图控制器的外观给人传达了更细腻的控制感。特别是新的全屏外观让你可以指定视图的每个边缘的布局。</p>
<p>UIViewController提供了如下属性来调整视图控制器的外观：</p>
<p>1.edgesForExtendedLayout：这个属性属于UIExtendedEdge类型，它可以单独指定矩形的四条边，也可以单独指定、指定全部、全部不指定。</p>
<p>使用edgesForExtendedLayout指定视图的哪条边需要扩展，不用理会操作栏的透明度。这个属性的默认值是UIRectEdgeAll。</p>
<p>2.extendedLayoutIncludesOpaqueBars：<br>如果你使用了不透明的操作栏，设置edgesForExtendedLayout的时候也请将 extendedLayoutIncludesOpaqueBars的值设置为No（默认值是YES）。</p>
<p>3.automaticallyAdjustsScrollViewInsets：如果你不想让scroll view的内容自动调整，将这个属性设为NO（默认值YES）。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define IOS7 [[[UIDevice currentDevice]systemVersion] floatValue] &gt;= 7.0</span></span><br><span class="line">/添加代码</span><br><span class="line"><span class="keyword">if</span> (IOS7)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.edgesForExtendedLayout</span> = <span class="built_in">UIRectEdgeNone</span>;               <span class="comment">//视图控制器，四条边不指定</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.extendedLayoutIncludesOpaqueBars</span> = <span class="literal">NO</span>;                 <span class="comment">//不透明的操作栏&lt;br&gt;    self.modalPresentationCapturesStatusBarAppearance = NO;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="constant">IOS7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.edgesForExtendedLayout = <span class="constant">UIRectEdgeNone</span>;</span><br><span class="line">        <span class="keyword">self</span>.extendedLayoutIncludesOpaqueBars = <span class="constant">NO</span>;</span><br><span class="line">        <span class="keyword">self</span>.modalPresentationCapturesStatusBarAppearance = <span class="constant">NO</span>;</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="constant">NO</span>;</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">self</span>.navigationController.navigationBar.translucent = <span class="constant">NO</span>;</span><br><span class="line"><span class="regexp">//</span>        <span class="keyword">self</span>.tabBarController.tabBar.translucent = <span class="constant">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<h1 id="iOS8和xcode6的坑">iOS8和xcode6的坑</h1><h2 id="1-NSUserDefaults">1.NSUserDefaults</h2><p>通过NSUserDefaults储存在本地的数据，在模拟器删除APP、clean之后无法清空数据，我尝试删除iPhone 4s、iPhone 5s……里面的同一个项目，还是无解，这应该是个BUG，等苹果更新Xcode吧（我目前用的6.0）。但是真机没有这种情况(必须的啊)</p>
<h2 id="2-UITableView坑">2.UITableView坑</h2><p>带有UITableView的界面如果到遇到以下警告</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning once only: Detected <span class="operator">a</span> <span class="keyword">case</span> where constraints ambiguously suggest <span class="operator">a</span> height <span class="operator">of</span> <span class="constant">zero</span> <span class="keyword">for</span> <span class="operator">a</span> tableview cell<span class="string">'s content view. We'</span>re considering <span class="operator">the</span> collapse unintentional <span class="operator">and</span> <span class="keyword">using</span> standard height instead.</span><br></pre></td></tr></table></figure>
<p>添加如下代码可解决</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">self</span>.<span class="built_in">table</span>View.rowHeight = <span class="number">44.0</span>f;</span><br></pre></td></tr></table></figure>
<h2 id="3-Tableview的detailTextLabel无法显示">3.Tableview的detailTextLabel无法显示</h2><p>先来看看下边的代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.array</span> = @[<span class="string">@"测试"</span>];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.tableView</span> reloadData];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"TradeRecordCell"</span></span><br><span class="line">                                                            forIndexPath:indexPath];</span><br><span class="line">    cell<span class="variable">.detailTextLabel</span><span class="variable">.text</span> = _array[indexPath<span class="variable">.row</span>];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码没什么问题，在iOS 7下，一秒之后cell的detailTextLabel就会显示测试两个字，但是在iOS 8却不行detailTextLabel显示为空。测试发现，当detailTextLabel的text一开始为空，iOS 8下运行就会把这个label的size设置(0, 0)从而不能正确显示，原因是这里cell.detailTextLabel.text = _array[indexPath.row];一开始数据就是空的，解决办法：</p>
<p>如果是空就不去设置值</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(_array[indexPath.row])</span> &#123;</span><br><span class="line">        cell.detailTextLabel.<span class="built_in">text</span> = _array[indexPath.row];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>或者是</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.detailTextLabel.<span class="type">text</span> = _array[indexPath.row] ? : @<span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
<h2 id="4-pch文件不见了">4.pch文件不见了</h2><p>现在Xcode 6创建的项目默认是不带pch文件的，当然了旧版本的项目是会保留的。那么如何添加pch文件？</p>
<ul>
<li>Command + N 然后在Other里面选择PCH File</li>
<li>在Build Settings里面找到Prefix Header</li>
</ul>
<p>添加pch文件，规则是: 项目名/xxxxx.pch</p>
<h2 id="5-UIAlertView的坑">5.UIAlertView的坑</h2><p>UIAlertView显示无标题的长文本问题</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIAlertView</span> *alterView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="literal">nil</span> message:<span class="string">@"远端Git仓库和标准的Git仓库有如下差别：一个标准的Git仓库包括了源代码和历史信息记录。我们可以直接在这个基础上修改代码，因为它已经包含了一个工作副本。"</span> delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@"知道了"</span> otherButtonTitles:<span class="literal">nil</span>, <span class="literal">nil</span>];</span><br><span class="line">[alterView show];</span><br></pre></td></tr></table></figure>
<p>上面这段代码在iOS 8下显示的样子是，内容完全顶到的顶部，文字还莫名其妙的加粗了</p>
<p>解决方法是–只要把title设置为@””就行了</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIAlertView *alterView = [[UIAlertView alloc] <span class="string">initWithTitle:</span>@<span class="string">""</span> <span class="string">message:</span>@<span class="string">"远端Git仓库和标准的Git仓库有如下差别：一个标准的Git仓库包括了源代码和历史信息记录。我们可以直接在这个基础上修改代码，因为它已经包含了一个工作副本。"</span> <span class="string">delegate:</span>self <span class="string">cancelButtonTitle:</span>@<span class="string">"知道了"</span> <span class="string">otherButtonTitles:</span>nil, nil];</span><br><span class="line">[alterView show];</span><br></pre></td></tr></table></figure>
<h2 id="6-iOS_tableview分割线短15像素_ios7（废弃）_iOS8方法">6.iOS tableview分割线短15像素 ios7（废弃） iOS8方法</h2><p>在xib中拖入一个tableview可以在右边的控制面板看到一个属性 Separator insetss 默认是Default，点开后可以发现能设置为Custom，系统默认分割线有离左边15像素的距离，把这个值改成0就好了。运行一下发现有数据的cell的分割线还是有15像素的距离，没有数据的cell直接顶格了.（适用于Xcode5）(然而这并没有什么卵用…)</p>
<p>我查询下 tableview delegate  我们会发现 ios7 增加了一些新属性，<br>@property (nonatomic)         UIEdgeInsets                separatorInset       NS_AVAILABLE_IOS(7_0)UI_APPEARANCE_SELECTOR;// allows customization of the frame of cell separators</p>
<p>这个时候你应改发现separatorInset 这个单词是否有点眼熟，  苹果公司已经给了注释，可以自定义视cell 的分割线，<br>UIEdgeInsets 是个结构体类型，这时候我们发现了我们要的属性 left</p>
<p>typedef struct UIEdgeInsets {<br>    CGFloat top, left, bottom, right; // specify amount to inset (positive) for each of the edges. values can be negative to ‘outset’<br>} UIEdgeInsets;</p>
<p>转载<br>现在我们可以用代码调用下面这个方法，</p>
<pre><code>[myTableView setSeparatorInset:UIEdgeInsetsMake(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)];
</code></pre><p>这时候你会发现你的tableview 的分割线是不是跟以前一样了呢!</p>
<p>在ios7中，UITableViewCell左侧会有默认15像素的空白。这时候，设置setSeparatorInset:UIEdgeInsetsZero 能将空白去掉。<br>但是在ios8中，设置setSeparatorInset:UIEdgeInsetsZero 已经不起作用了。下面是解决办法</p>
<p>在iOS8中可以使用代码来去掉所有分割线的15像素，方法如下</p>
<p>首先在viewDidLoad中添加如下代码</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> ([self.tableview_aoto <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setSeparatorInset</span>:)]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="attr_selector">[self.tableview_aoto setSeparatorInset:UIEdgeInsetsZero]</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="tag">if</span> ([self.tableview_aoto <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setLayoutMargins</span>:)]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="attr_selector">[self.tableview_aoto setLayoutMargins:UIEdgeInsetsZero]</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后再tableview的代理方法中添加如下代码</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">tableView</span>:(UITableView *)<span class="tag">tableView</span> <span class="tag">willDisplayCell</span>:(UITableViewCell *)<span class="tag">cell</span> <span class="tag">forRowAtIndexPath</span>:(NSIndexPath *)<span class="tag">indexPath</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="tag">if</span> ([cell <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setSeparatorInset</span>:)]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="attr_selector">[cell setSeparatorInset:UIEdgeInsetsZero]</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="tag">if</span> ([cell <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setLayoutMargins</span>:)]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="attr_selector">[cell setLayoutMargins:UIEdgeInsetsZero]</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后可以看到所有的分割线全部顶格了</p>
<p><img src="http://7xlip0.com1.z0.glb.clouddn.com/aiOS%20Simulator%20Screen%20Shot%202015年9月2日%20上午9.55.13.png" alt="图片"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/01/随笔小记/" data-id="ciedk5crs00013pi0ug7z1su0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS预览文件类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/31/iOS预览文件类/" class="article-date">
  <time datetime="2015-08-31T06:21:21.000Z" itemprop="datePublished">2015-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/31/iOS预览文件类/">iOS预览文件类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于 DocumentInteraction</p>
<p>iOS支持在你的app中用其他app预览和显示文档。iOS还支持文件关联，允许其他app通过你的程序打开文件。这些技术包括了UIKit中提供的UIDocumentInteractionController类（ UIDocumentInteractionController Class Reference)，以及Quick Look框架（Quick Look Framework Reference)。</p>
<p>DocumentInteraction的具体使用</p>
<p>首先创建UIDocumentInteractionController实例，并添加代理，代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Previewontroller</span> ()&lt;<span class="title">UIDocumentInteractionControllerDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIDocumentInteractionController</span> *documentinteractioncontroller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span><span class="variable">.documentinteractioncontroller</span><span class="variable">.delegate</span> = <span class="keyword">self</span>;`</span><br></pre></td></tr></table></figure>
<p>DocumentInteraction Controller使用静态方法interactionControllerWithURL创建实例，这个方法使用一个NSURL作为参数。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"aaa"</span> withExtension:<span class="string">@"pdf"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.documentinteractioncontroller</span> = [<span class="built_in">UIDocumentInteractionController</span> interactionControllerWithURL:url];</span><br></pre></td></tr></table></figure>
<p>Document Interaction Controller对象使用presentPreviewAnimated方法弹出一个全屏的文档预览窗口。代码如下</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[self.documentinteractioncontroller presentPreviewAnimated:YES]</span><span class="comment">;`</span></span><br></pre></td></tr></table></figure>
<p>使用委托 如果你显示一个Document Interaction Controller ，则必需要为delegate属性用指定一个委托。让委托告诉DocumentInteraction Controller如何显示。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="list">(<span class="keyword">UIViewController</span> <span class="variable">*)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *</span>)</span>controll</span><br></pre></td></tr></table></figure>
<p>系统默认的预览窗口语言是英文，想改成中文的话要更改info.plist文件的Localization native development region（定位本地开发地区）为China，这样预览窗口就变成中文了</p>
<p>点击预览串口的done 调用代理中的</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">documentInteractionControllerDidEndPreview</span>:<span class="value">(UIDocumentInteractionController *)controller</span></span>;`</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/31/iOS预览文件类/" data-id="ciedk5crw00033pi0flumwzkz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/09/10/Xmpp导入Xcode/">Xmpp导入Xcode</a>
          </li>
        
          <li>
            <a href="/2015/09/10/Xcode6-4添加pch文件/">Xcode6.4添加pch文件</a>
          </li>
        
          <li>
            <a href="/2015/09/06/设置appicon和启动图/">设置appicon和启动图</a>
          </li>
        
          <li>
            <a href="/2015/09/02/iOS面试题和参考答案（下篇）/">iOS面试题和参考答案（下篇）</a>
          </li>
        
          <li>
            <a href="/2015/09/02/iOS面试题和参考答案（上篇）/">iOS面试题和参考答案（上篇）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Zhangdong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>